<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[书签]]></title>
    <url>%2F2060%2F04%2F27%2F%E4%B9%A6%E7%AD%BE%2Findex.html</url>
    <content type="text"><![CDATA[新闻流 Hacker News 书单 YuQue 📚免费的开源书籍 开源书单 学习卡片，界面清新 汇编语言初级教程 Go 高级教程 前端开发者手册2019版 提供中国古籍电子版 MIT 的数据结构课程 面经 Google 游戏类 INDIENOVA游戏素材 VIM 通过游戏的方式学习 VIM 编辑器 艺术类 自动化配色 颜色届的谷歌，可以根据情感搜索颜色 谷歌色彩秘籍：色彩用不好？学会这2招，受用终身 Dapollo设计开发工作台 for sketch 资源 PEXELS PIXABAY UNSPLASH 图片 API PAIXIN中的免费专区 一套可以定制的 SVG 图标 780+ Free Vector Emoji 一些24*24的图标 自动生成背景图片的工具网站 SVG 图标库 新华词典 数据 开源卡通头像生成器 全历史 一个演示汉字笔画顺序的 JS 库 一些免费的UI设计稿 sketch 等 有趣的图标（浏览器、猫、文件、茶杯等）React Component 图标 ICONFONT 简单图标 Feather – 项目地址 信息聚集 搜索 电子书 Pholcus（幽灵蛛）是一款纯Go语言编写的高并发、分布式、重量级爬虫软件 软件安转 安装虚幻引擎 MAC破解软件 免费SSL证书 freessl 实用的 JavaScript 库书籍教程 前端面试手册 有趣的代码片段 Node 初级教程 实用库 CSS样式缩写策略 Tailwind CSS 具有演示效果的组件文档生成器 录制命令行操作，生成 SVG 使用 React 组件写命令行脚本的框架 造”假”数据 Faker – 项目地址 字符串各种格式校验 Leaflet 地图库 – 项目地址 Sortable 块级爽快拖拽 – 项目地址 Draggable 丝滑拖拽 – 项目地址 Dropzone 拖拽上传 – 项目地址 Uppy 不仅仅拖拽上传 – 项目地址 Html2canvas 截图 – 项目地址 Tesseract 识别图片中的文字 – 项目地址 medium-zoom 图片查看器 Prismjs 小巧高亮 – 项目地址 Highlightjs 传统高亮 – 项目地址 视频播放控制 VideoJs – 项目地址 剪贴板 ClipboardJs – 项目地址 PDF 阅读 PDF 生成器 – 项目地址 SnapSvg 丝般柔滑操控SVG画画 – 项目地址 React-Motion react 优质动画库 特效绚丽库 一个 React 组件，按钮点击后会像粒子状消解 Velocity 动画库 – 项目地址 Anime 丝般柔滑动画 – 项目地址 滚动渐现柔滑控制 – 项目地址 颗粒特效库 Particles – 项目地址 Mojs 艺术特效画板 – 项目地址 可视化 D3 – 项目地址 3D 库 ThreeJs – 项目地址 2D WebGL 渲染 PixiJS – 项目地址 2D 游戏库 Phaser – 项目地址 Carbon 代码化妆器 – 项目地址 SVGA Android、IOS、web动画 lottie 动画库 react native lottie 动画 玩具 磁链接下载 – 项目地址 浏览器操作系统 职场 创业公司如何避免“死海效应”，留住厉害的员工？ 刷刷面试题呗CareerCup 性能 jsperf JS性能测试 工具 ssl 证书安装检测 免费的图片压缩神器网站 谷歌出品 Canva 让设计更加简单，在线设计 DBDiagram 制作数据库关系图的在线工具 数据库 数据库原理 how databases work | 译 其他 storybook 用作组件库在线例子，是个不错的选择 一个神奇的文档网站生成工具 docsify 申明：书签只做学习研究使用，不承担一切可能涉及到的法律责任，侵删！ 如果你也有比较好的书签，可以在下方评论区分享一哈 ^o^]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【一】从零开始学习ios app开发（swift）]]></title>
    <url>%2F2022%2F03%2F25%2F%E3%80%90%E4%B8%80%E3%80%91%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0ios_app%E5%BC%80%E5%8F%91%EF%BC%88swift%EF%BC%89%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[深入理解浏览器]]></title>
    <url>%2F2019%2F06%2F28%2F%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F%2Findex.html</url>
    <content type="text"><![CDATA[介绍作为前端开发者，我们知道硬件加速(hardware acceleration)能够提升页面的渲染性能，提高动画的流畅度。也知道可以通过设置transform等CSS3属性来手动开启硬件加速，也就是GPU加速。本文将介绍在 Chrome 中，为 web 内容提供硬件加速的基本模型。 申明本文中讨论的内容都是基于 Chrome 浏览器，也就是 WebKit 内核，更准确的说，是讨论 WebKit 的 Chromium 分支。本文描述的是 Chrome 的实现细节，而并非是 web 平台的功能。web 平台和标准不会对这种层面的实现细节制定规则，因此文中介绍的内容不一定适用于其他浏览器，但是了解内部实现对于高级调试和性能优化有着不小的帮助。 书写时：Chrome： 版本 74.0.3729.169（正式版本） （64 位） 由于AppStore限制了所有app必须使用UIWebView(Apple对WebKit的封装），IOS自不用说，跑&gt; 着的全是webkit内核，主流安卓手机上的主流浏览器如 Android Browser, UC Browser,Opera Mini, Opera Mobile, Chrome 等也都是 webkit 内核。 浏览器发展简史 想看更清晰的，可以前往：图片原址 更多详细信息，可以去谷歌一下，蛮多的，下面是一些看上去整理的还不错的信息： 野史类 小文：浅谈浏览器发展简史（中文） 知识类 Timeline_of_web_browsers（英文） 浏览器的基本结构大抵如下图： Webkit 渲染基础要提供快速的网络体验，浏览器需要做许多工作。这类工作大多数是我们这些网络开发者看不到的：我们编写代码（HTML、CSS 和 JavaScript ），屏幕上就会显示出漂亮的页面。 浏览器中页面的渲染过程可以简化为以下五个步骤： 而浏览器渲染页面前需要先构建 DOM 和 CSSOM 树。因此，我们需要确保尽快将 HTML 和 CSS 都提供给浏览器。 浏览器处理页面流程首先来看下一个简单的页面（一个包含一些文本和一幅图片的普通 HTML 页面）123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1"&gt; &lt;link href="style.css" rel="stylesheet"&gt; &lt;title&gt;Critical Path&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt; &lt;div&gt;&lt;img src="awesome-photo.jpg"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 浏览器如何处理此页面？ DOM 的建立 转换： 浏览器从磁盘（缓存）或网络读取 HTML 的原始字节，并根据文件的指定编码（例如 UTF-8）将它们转换成各个字符。 标签化： 浏览器将字符串转换成 W3C HTML5 标准规定的各种标签，例如，“&lt;html&gt;”、“&lt;body&gt;”，以及其他尖括号内的字符串。每个标签都具有特殊含义和一组规则。 词法分析： 将标签转换成“对象”，用来定义其属性和规则 DOM 构建： 根据原来的 HTML 标签的结构构建成一颗树，记录原始标签之间的关系：HTML 对象是 body 对象的父项，body 是 paragraph 对象的父项，依此类推。 整个流程的最终输出是我们这个简单页面的文档对象模型 (DOM)，浏览器对页面进行的所有进一步处理都会用到它。 浏览器处理 HTML 标签，都会经过上述4个步骤：转换、标签化、词法分析、DOM 构建。 CSSOM 的建立在浏览器构建我们这个简单页面的 DOM 时，在文档的 head 部分遇到了一个 link 标记，该标记引用一个外部 CSS 样式表：style.css。由于预见到需要利用该资源来渲染页面，它会立即发出对该资源的请求，并返回以下内容： 12345body &#123; font-size: 16px &#125;p &#123; font-weight: bold &#125;span &#123; color: red &#125;p span &#123; display: none &#125;img &#123; float: right &#125; 浏览器处理 CSS 的这个过程，会重复 DOM 的建立过程，只是输出的是 CSSOM CSS 字节转换成字符，接着转换对应标签和节点，最后链接到一个称为“CSS 对象模型”(CSSOM) 的树结构内： CSSOM 为何具有树结构？因为页面上的任何对象计算最后一组样式时，浏览器都会先从适用于该节点的最通用规则开始（例如，如果该节点是 body 元素的子项，则应用所有 body 样式），然后通过应用更具体的规则（即规则“向下级联”）以递归方式优化计算的样式。 以上面的 CSSOM 树为例进行更具体的阐述。span 标记内包含的任何置于 body 元素内的文本都将具有 16 像素字号，并且颜色为红色 — font-size 指令从 body 向下级联至 span。不过，如果某个 span 标记是某个段落 (p) 标记的子项，则其内容将不会显示。 还请注意，以上树并非完整的 CSSOM 树，它只显示了我们决定在样式表中替换的样式。每个浏览器都提供一组默认样式（也称为“User Agent 样式”），即我们不提供任何自定义样式时所看到的样式，我们的样式只是替换这些默认样式。 合并渲染CSSOM 树和 DOM 树合并成渲染树，然后用于计算每个可见元素的布局，并输出给绘制流程，将像素渲染到屏幕上。 1. 构建渲染树阶段第一步是让浏览器将 DOM 和 CSSOM 合并成一个“渲染树”，网罗网页上所有可见的 DOM 内容，以及每个节点的所有 CSSOM 样式信息。 为构建渲染树，浏览器大体上完成了下列工作： 从 DOM 树的根节点开始遍历每个可见节点。 某些节点不可见（例如脚本标记、元标记等），因为它们不会体现在渲染输出中，所以会被忽略。 某些节点通过 CSS 隐藏，因此在渲染树中也会被忽略，例如，上例中的 span 节点不会出现在渲染树中，因为有一个显式规则在该节点上设置了“display: none”属性。（注意display: none 和 visibility: hidden的区别，前者不在渲染树上，后者是存在的，只是不可见罢了） 对每个可见节点，找到适配的 CSSOM 规则。 放置准备好的节点（内容和计算的样式）。 2. 布局阶段（重排 Reflow）浏览器从渲染树的根节点进行遍历，获取每个节点的确切大小和位置，然后再进行布局，看一个简单的例子： 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1"&gt; &lt;title&gt;Critial Path: Hello world!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div style="width: 50%"&gt; &lt;div style="width: 50%"&gt;Hello world!&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 以上网页的正文包含两个嵌套 div： 第一个（父）div 将节点的显示尺寸设置为视口宽度的 50% 父 div 包含的第二个 div =&gt; 将其宽度设置为其父项的 50%，即视口宽度的 25%。 布局流程的输出是一个“盒模型”（注意标准盒模型和IE盒模型的区别），它会精确地捕获每个元素在视口内的确切位置和尺寸：所有相对测量值都转换为屏幕上的绝对像素。 3. 绘制阶段（栅格化）将渲染树中的每个节点转换成屏幕上的实际像素，这就是浏览器的绘制阶段了，或者说是栅格化阶段。 总结（浏览器处理页面流程） 构建DOM 树阶段：处理 HTML 标记并构建 DOM 树。 CSSOM 树阶段：处理 CSS 标记并构建 CSSOM 树。 合并渲染树阶段：将 DOM 与 CSSOM 合并成一个渲染树。 布局（重排）阶段：根据渲染树来布局，以计算每个节点的几何信息。 绘制（栅格化）阶段：将各个节点绘制到屏幕上。 层当页面加载并解析完毕后，它在浏览器内代表了一个大家十分熟悉的结构：DOM。在浏览器渲染一个页面时，它使用了许多没有暴露给开发者的中间表现形式。其中最重要的结构便是层(layer)。 Chrome 中有不同类型的层： RenderLayer(负责 DOM 子树)，GraphicsLayer(负责 RenderLayer 的子树)。其中只有 GraphicsLayer 是作为纹理(texture)上传给 GPU 的。 从 DOM 到 RenderObjectRenderObject 是衔接浏览器排版引擎和渲染引擎之间的桥梁，它是排版引擎的输出和渲染引擎的输入。当 Webkit 创建 RenderObject 对象之后，每个对象是不知道自己的位置、大小等信息的，Webkit 根据框模型来计算它们的位置、大小等信息的过程称为布局计算。 从 RenderObject 到 RenderLayerWebkit 会为网页的层次创建相应的 RenderLayer 对象，当某些类型的 RenderObject 的节点或者具有某些 CSS 样式的 RenderObject 节点出现的时候，Webkit 就会为这些节点创建 RenderLayer 对象，一般来说某个 RenderObject 节点的后代都属于该节点的 RenderLayer，除非 Webkit 根据规则为某个后代 RenderObject 节点创建一个新的 RenderLayer 对象，以下是 RenderObject 节点需要建立新的 RenderLayer 节点的规则： DOM 树的 document 节点对应的 RenderView 节点 DOM 树中 document 的子女节点，即 html 节点对应的 RenderBlock 节点 显示指定 CSS 位置的 RendrObject 节点 有透明效果的 RenderObject 节点 节点有溢出（overflow）、alpha 或者反射等效果的 RenderObject 节点 适用 canvas 2d 或者 3d（WebGL）技术的 RenderObject 节点 video 节点对应的 RenderObject 节点 软件渲染和硬件加速渲染在 Webkit 中绘图操作被定义为一个抽象层即绘图上下文，所有绘图操作都是在该上下文中进行，可以分为两种类型：2d 图形上下文和 3d 图形上下文。其中 2d 图形上下文的具体作用就是提供基本绘图单元的绘制接口以及设置绘图的样式，绘图接口包括画点、画线、画图片、画多边形、画文字 etc.，绘图样式包括颜色、线宽、字号大小、渐变 etc.，而RenderObject 对象知道自己需要画什么样的点，什么样的图片。3d 绘图上下文的主要用处是支持 CSS3D、WebGL etc.。 网页的渲染方式主要有两种：软件渲染和硬件加速渲染。每个 RenderLyaer 对象都可以被想象成一个层，各个层一同构成一个图像，在渲染过程中，每个层对应网页中的一个或者一些可视元素，这些元素都绘制内容到该层上，如果这些绘图操作由 CPU 莱完成则称之为软件绘图，如果这些绘图操作由 GPU 来完成则称之为硬件加速绘图。理想情况下，每个层都有绘制的存储区域来保存绘图的结果，最后需要将这些层的内容合并到同一个图像中的过程称为合成（compositing），使用合成技术的渲染叫做合成化渲染。 对于软件渲染机制，Webkit 需要使用 CPU 来绘制每层的内容，然而该机制是没有合成阶段的：在软件渲染中通常其结果就是一个位图（Bitmap），绘制每一层时都使用同一个位图，区别在于绘制的位置看你不一样，每一层都按照从后到前的顺序。而使用合成化的渲染技术，以使用软件绘图的合成化渲染为例，对于使用 CPU 绘制的层，其结果保存在 CPU 内存中，之后传输到 GPU 中进行合成。 从 RenderLayer 到 GraphicsLayer每个 GraphicsLayer 都拥有一个 GraphicsContext，用于为该 GraphicsLayer 开辟一段位图，也就意味着每个 GraphicsLayer 都拥有一个独立的位图，GraphicsLayer 负责将自己的 RenderLayer 及其所包含的 RenderObject 绘制到位图里，然后将位图作为纹理交给 GPU 进行合成。如果一个 RenderLayer 对象具有以下特征之一，那么它就是合成层： RenderLayer 具有 CSS3D 属性或者 CSS 透视效果 RenderLayer 包含 video 节点对应的 RenderObject 节点 RenderLayer 包含使用 canvas 2d 或者 3d（WebGL）技术的 RenderObject 节点 混合插件(如 Flash) RenderLayer 使用 CSS 透明效果的动画或者 CSS 变换动画 RenderLayer 使用硬件加速的 CSS Filters 技术 元素有一个包含合成层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里) 元素有一个 z-index 较低且包含一个合成层的兄弟元素(换句话说就是该元素在复合层上面渲染) 什么是纹理纹理其实就是 GPU 中的位图，存储在 GPU video RAM 中。前面说的位图里的元素存什么我们自己定义好就行（是用3字节存256位rgb还是1个bit存黑白自己定义即可），但纹理是 GPU 专用的，需要有固定格式便于兼容与处理，所以一方面纹理的格式比较固定，如 R5G6B5、A4R4G4B4 等像素格式， 另外一方面 GPU 对纹理的大小有限制，比如长/宽必须是2的幂次方，最大不能超过2048或者4096等。 合成层的规则细分： 元素本身原因 硬件加速的 iframe 元素（比如 iframe 嵌入的页面中有合成层） video 元素 覆盖在 video 元素上的视频控制栏 3D 或者 硬件加速的 2D Canvas 元素 硬件加速的插件：比如 flash etc. 在 DPI 较高的屏幕上 fix 定位的元素会自动地被提升到合成层中；但在 DPI 较低的设备上却并非如此：因为这个渲染层的提升会使得字体渲染方式由子像素变为灰阶 有 3D transform backface-visibility 为 hidden 对 opacity、transform、fliter、backdropfilter 应用 animation 或者 transition（需要是 active 的 animation 或者 transition，当 animation 或者 transition 效果未开始或结束后，提升合成层也会失效） will-change 设置为 opacity、transform、top、left、bottom、right（其中 top、left 等需要设置明确的定位属性：比如 relative etc.） 后代元素原因 有合成层后代同时本身有 transform、opactiy（小于 1）、mask、fliter、reflection 属性 有合成层后代同时本身 overflow 不为 visible（如果本身是因为明确的定位因素产生的 SelfPaintingLayer，则需要 z-index 不为 auto） 有合成层后代同时本身 fixed 定位 有 3D transfrom 的合成层后代同时本身有 preserves-3d 属性 有 3D transfrom 的合成层后代同时本身有 perspective 属性 重叠原因重叠或者说部分重叠在一个合成层之上，最常见和容易理解的就是元素的 border box（content + padding + border） 和合成层的有重叠，其他的还有一些不常见的情况，也算是同合成层重叠的条件如下： filter 效果同合成层重叠 transform 变换后同合成层重叠 overflow scroll 情况下同合成层重叠 假设重叠在一个合成层之上，其实也比较好理解，比如一个元素的 CSS 动画效果在运行期间，元素有可能和其他元素发生重叠的情况，需要注意的是该原因下，有一个很特殊的情况：如果合成层有内联的transform 属性，会导致其兄弟渲染层假设重叠从而提升为合成层。 由于重叠的原因可能随随便便就会产生出大量合成层来，而每个合成层都要消耗 CPU 和内存资源，会严重影响页面性能。 层压缩层压缩（Layer Squashing）的处理。如果多个渲染层同一个合成层重叠时，这些渲染层会被压缩到一个 GraphicsLayer 中，以防止由于重叠原因导致可能出现的“层爆炸”。 当然，浏览器的自动层压缩也不是万能的，在很多特定情况下，浏览器是无法进行层压缩的，而这些情况也是我们应该尽量避免的（以下情况都是基于重叠原因而言）： 无法进行会打破渲染顺序的压缩 video 元素的渲染层无法被压缩，同时也无法将别的渲染层压缩到 video 所在的合成层上 iframe、plugin 的渲染层无法被压缩，同时也无法将别的渲染层压缩到其所在的合成层上 无法压缩有 reflection 属性的渲染层 无法压缩有 blend mode 属性的渲染层 当渲染层同合成层有不同的裁剪容器时，该渲染层无法压缩 相对于合成层滚动的渲染层无法被压缩 当渲染层同合成层有不同的具有 opacity 的祖先层（一个设置 opacity 且小于 1 一个没有设置 opacity 也算是不同）时，该渲染层无法压缩 当渲染层同合成层有不同的具有 transform 的祖先层时，该渲染层无法压缩 当渲染层同合成层有不同的具有 filter 的祖先层时，该渲染层无法压缩 当覆盖的合成层正在运行动画时，该渲染层无法压缩，只有在动画未开始或者运行完毕以后，该渲染层才可以被压缩 重排&amp;重绘重排如果改变了一个影响元素布局信息的 CSS 样式：比如 width、height、left、top etc.，那么浏览器会将当前的 Layout 标记为 dirty，这会使得浏览器在下一帧执行重排，因为元素的位置信息发生改变将可能会导致整个网页其他元素的位置情况都发生改变，所以需要执行 Layout 全局重新计算每个元素的位置。 强制重排如果你在当前 Layout 被标记为 dirty 的情况下访问 offsetTop、scrollHeight 等属性，那么浏览器会立即重新 Layout，计算出此时元素正确的位置信息，以保证你在 JS 里获取到的 offsetTop、scrollHeight 等是正确的。 这一过程被称为强制重排 Force Layout，强制浏览器将本来在渲染流程中才执行的 Layout 过程提前至 JS 执行过程中，每次当我们在 Layout 为 dirty 时访问会触发重排的属性都会 Force Layout，这会极大延缓 JS 的执行效率。 另外，每次重排或者强制重排后，当前 Layout 就不再 dirty，这时再访问 offsetWidth 之类的属性并不会再触发重排。 重绘一旦更改某个元素的会触发重绘的样式，那么浏览器就会在下一帧的渲染步骤中进行重绘（也即一些介绍重绘机制中说的invalidating），JS 更改样式导致某一片区域的样式作废，从而在一下帧中重绘 invalidating 的区域。 重绘是以合成层为单位的，也即 invalidating 的既不是整个文档也不是单个元素，而是这个元素所在的合成层。当然这也是将渲染过程拆分为 Paint 和 Compositing 的初衷之一： Since painting of the layers is decoupled from compositing, invalidating one of these layers only results in repainting the contents of that layer alone and recompositing. 回忆下浏览器的渲染步骤图： TIP：如果想要知道修改了元素属性，到底是触发重排还是重绘，网上有作出了总结：传送门 ，如果不能访问，请科学上网。部分截图： Chrome 如何计算合成层可以操考如下图： 浏览器渲染流程可以简化总结如下： GPU加速的实际意义动画最常见的一个就是动画了，开启 GPU 加速对动画流畅度的优化程度，是肉眼可见的，但是，切记谨慎开启GPU加速，而不要一股脑的全部开启，那样会卡成幻灯片的。 滚动来个例子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Composited layer&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=no&quot; /&gt; &lt;style type=&quot;text/css&quot;&gt; body &#123; font-family: &apos;Helvetica Neue&apos;, &apos;Microsoft Yahei&apos;, sans-serif; &#125; @-webkit-keyframes move &#123; 0% &#123; -webkit-transform:translateX(0px) &#125; 50% &#123; -webkit-transform:translateX(10px) &#125; 100% &#123; -webkit-transform:translateX(0px) &#125; &#125; @-moz-keyframes move &#123; 0% &#123; -moz-transform:translateX(0px) &#125; 50% &#123; -moz-transform:translateX(10px) &#125; 100% &#123; -moz-transform:translateX(0px) &#125; &#125; @-o-keyframes move &#123; 0% &#123; -o-transform:translateX(0px) &#125; 50% &#123; -o-transform:translateX(10px) &#125; 100% &#123; -o-transform:translateX(0px) &#125; &#125; @keyframes move &#123; 0% &#123; transform:translateX(0px) &#125; 50% &#123; transform:translateX(10px) &#125; 100% &#123; transform:translateX(0px) &#125; &#125; #title &#123; -webkit-animation: move 1s linear infinite; -moz-animation: move 1s linear infinite; -o-animation: move 1s linear infinite; animation: move 1s linear infinite; /*position: relative; z-index: 1;*/ &#125; h1 &#123; font-size: 20px; &#125; a &#123; color: #888; text-decoration: none; &#125; div &#123; overflow: hidden; &#125; ul &#123; margin: 5px; padding: 0; &#125; li &#123; position: relative; height: 30px; overflow: hidden; border-top: 1px dotted #ccc; padding: 5px 20px 5px 40px; font-size: 20px; &#125; img &#123; width: 30px; height: 30px; position: absolute; left: 3px; top: 4px; border: 1px solid #ccc; &#125; time &#123; position: absolute; right: 5px; top: 4px; font-size: 12px; color: #999; &#125; label &#123; display: block; margin: 10px 5px; color: red; &#125; input &#123; vertical-align: middle; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;h1 id=&quot;title&quot;&gt;请使用具备『硬件加速』功能的『安卓』手机浏览此页面&lt;/h1&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot; onchange=&quot;setZIndex(this)&quot;&gt; 为动画元素设置z-index &lt;/label&gt; &lt;/div&gt; &lt;ul id=&quot;list&quot;&gt;&lt;/ul&gt; &lt;script&gt; // 处理query var query = (function(query)&#123; var q = &#123;&#125;; query = query.replace(/^\?+/, &apos;&apos;); if(query)&#123; query.split(&apos;&amp;&apos;).forEach(function(i)&#123; i = i.split(&apos;=&apos;); q[i[0]] = i[1]; &#125;); &#125; return q; &#125;)(location.search); &lt;/script&gt; &lt;script&gt; var $ = function(selector)&#123; return document.querySelector(selector); &#125;; &lt;/script&gt; &lt;script&gt; var setZIndex = function(checkbox)&#123; var title = $(&apos;#title&apos;); if(checkbox.checked)&#123; title.style.position = &apos;relative&apos;; title.style.zIndex = 1; &#125; else &#123; title.style.position = &apos;static&apos;; &#125; &#125;; // 生成DOM var template = function(i)&#123; return [ &apos;&lt;li class=&quot;album-item&quot;&gt;&apos;, &apos;&lt;img src=&quot;assets/&apos; + (i % 16) + &apos;.png&quot;/&gt;&apos;, &apos;hello world&apos;, &apos;&lt;time&gt;2015-09&lt;/time&gt;&apos;, &apos;&lt;/li&gt;&apos; ].join(&apos;&apos;); &#125;; var size = parseInt(query.size) || 2000; var html = &apos;&apos;; for(var i = 0; i &lt; size; i++)&#123; html += template(i); &#125; $(&apos;#list&apos;).innerHTML = html; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 体验下两种不同的情况下，滚动的流畅程度，也是肉眼可见的，只修改了一个属性，就可以有很大的性能提升。（这其实是反例，开启多了会更卡） 参考文章 没有排序，部分链接需要科学上网 Accelerated Rendering in ChromeScrolling PerformanceTexture compression WikiA Reference Architecture for Web BrowsersGPU Accelerated Compositing in ChromeOn translate3d and layer creation hacksGPU加速是什么CSS GPU Animation: Doing It Right 译 这样使用 GPU 渲染 CSS 动画使用CSS3 will-change提高页面滚动、动画等渲染性能CSS BEM 书写规范关键渲染路径css triggers浏览器的工作原理：新式网络浏览器幕后揭秘Webkit技术内幕Web 性能优化-CSS3 硬件加速(GPU 加速)理解WebKit和Chromium: 硬件加速之RenderLayer树到合成树]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何设置nginx重定向]]></title>
    <url>%2F2018%2F09%2F21%2F%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEnginx%E9%87%8D%E5%AE%9A%E5%90%91%2Findex.html</url>
    <content type="text"><![CDATA[nginx 是一个灵活且高效的网络服务器，如果想要在nginx服务器中重定，你可以从下面挑选一个适合的方式。 简单且快速的 return这是一个非常简单的设置方式，只需要个return语句就可以了1return 301 https://example.com$request_uri; 你需要把这段代码放到nginx配置文件的server代码块中，301是永久重定向，你也可以设置成302做一个临时重定向（不建议）。 一个完整的例子：123456server &#123; listen 80; listen [::]:80; hostname example.com www.example.com; return 301 https://example.com$request_uri;&#125; 正则表达式 rewrite如果return不能满足你的复杂业务需求，你可以考虑下正则匹配重定向：1rewrite ^/foo/(bar)/(.*)$ https://$server_name/$1/$2 permanent; 同样这也是需要在server代码块中，其中permanent为301永久跳转，若需要302可修改为redirect 一个完整的例子：1234567server &#123; listen 80; listen [::]:80; hostname example.com www.example.com; root /var/www/example.com/public; rewrite ^/foo/(bar)/(.*)$ $scheme://$server_name/$1/$2 permanent;&#125; 又如：1234567server &#123; listen 80; server_name www.fangyongle.com fangyongle.cn; if ($host != 'www.fangyongle.com' ) &#123; rewrite ^/(.*)$ https://www.fangyongle.com/$1 permanent; &#125; &#125; 再如：1234567# 根据文件类型设置过期时间location ~* \.(js|css|jpg|jpeg|gif|png|swf)$ &#123; if (-f $request_filename) &#123; expires 1h; break; &#125;&#125; 使用Maps如果你有一堆需要重定向的连接映射，你可以考虑在一个地方定义它，然后再通过if来手动判断重定向。 首先定义重定向链接映射redirect-map.conf12345map $request_uri $redirect_uri &#123; /about.html /about-us; /customers.html /our-customers; /products.html /our-products;&#125; 然后在server代码块使用：1234567include redirect-map.conf;server &#123; […] if ( $redirect_uri ) &#123; return 301 $redirect_uri; &#125;&#125; 映射也可以有一些语法：123456789101112map $request_uri $redirect_uri &#123; /about.html /about-us; /customers.html /our-customers; /products.html /our-products; # Match any url that ends in products.html or producs.htm ~products\.html?$ /our-products; # case-insensitive version of the above ~*products\.html?$ /our-products; # A named capture that maps # e.g. product-1234.html into /products/item-1234/overview ~product-(?&lt;sku&gt;\d+)\.html /products/item-$sku/overview;&#125; 一些实用的重定向例子http 重定向为 https1return 301 https://$host$request_uri; 统一规范域名1234server_name example.com www.example.com example.net www.example.net _;if ( $host != $server_name ) &#123; return 301 $scheme://$server_name$request_uri;&#125; 含 www 和 不含 www 之间的重定向1234# non-www to wwwif ( $host !~ ^www\. ) &#123; return 301 $scheme://www.$host$request_uri;&#125; 1234# www to non-wwwif ( $host ~ ^www\.(?&lt;domain&gt;.+)$ ) &#123; return 301 $scheme://$domain$request_uri;&#125; 附录重定向中常用全局变量12345$scheme // HTTP方法（如http，https）,如：http$host // 请求主机头字段，否则为服务器名称，如:blog.fangyongle.com$server_name // 服务器名称，如：blog.fangyongle.com$request_uri // 包含请求参数的原始URI，不包含主机名，如：/2018/81.html?a=1&amp;b=2$request_filename // 当前请求的文件的路径名，由root或alias和URI request组合而成，如：/2013/81.html nginx 部分常用全局变量123456789101112131415161718192021222324252627282930313233$remote_addr //获取客户端ip$binary_remote_addr //客户端ip（二进制)$remote_port //客户端port，如：50472$remote_user //已经经过Auth Basic Module验证的用户名$host //请求主机头字段，否则为服务器名称，如:blog.fangyongle.com$request //用户请求信息，如：GET ?a=1&amp;b=2 HTTP/1.1$request_filename //当前请求的文件的路径名，由root或alias和URI request组合而成，如：/2013/81.html$status //请求的响应状态码,如:200$body_bytes_sent // 响应时送出的body字节数数量。即使连接中断，这个数据也是精确的,如：40$content_length // 等于请求行的“Content_Length”的值$content_type // 等于请求行的“Content_Type”的值$http_referer // 引用地址$http_user_agent // 客户端agent信息,如：Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.76 Safari/537.36$args //与$query_string相同 等于当中URL的参数(GET)，如a=1&amp;b=2$document_uri //与$uri相同 这个变量指当前的请求URI，不包括任何参数(见$args) 如:/2018/81.html$document_root //针对当前请求的根路径设置值$hostname //如：centos53.localdomain$http_cookie //客户端cookie信息$cookie_COOKIE //cookie COOKIE变量的值$is_args //如果有$args参数，这个变量等于”?”，否则等于”"，空值，如?$limit_rate //这个变量可以限制连接速率，0表示不限速$query_string // 与$args相同 等于当中URL的参数(GET)，如a=1&amp;b=2$request_body // 记录POST过来的数据信息$request_body_file //客户端请求主体信息的临时文件名$request_method //客户端请求的动作，通常为GET或POST,如：GET$request_uri //包含请求参数的原始URI，不包含主机名，如：/2018/81.html?a=1&amp;b=2$scheme //HTTP方法（如http，https）,如：http$uri //这个变量指当前的请求URI，不包括任何参数(见$args) 如:/2018/81.html$request_completion //如果请求结束，设置为OK. 当请求未结束或如果该请求不是请求链串的最后一个时，为空(Empty)，如：OK$server_protocol //请求使用的协议，通常是HTTP/1.0或HTTP/1.1，如：HTTP/1.1$server_addr //服务器IP地址，在完成一次系统调用后可以确定这个值$server_name //服务器名称，如：blog.fangyongle.com$server_port //请求到达服务器的端口号,如：80 Rewrite正则相关指令详解nginx的rewrite相当于apache的rewriterule(大多数情况下可以把原有apache的rewrite规则加上引号就可以直接使用)，它可以用在server,location和IF条件判断块中，命令格式如下：1rewrite &lt;regex&gt; &lt;replacement&gt; &lt;flag&gt; 正则表达式匹配 ~为区分大小写匹配 ~*为不区分大小写匹配 !~和!~*分别为区分大小写不匹配及不区分大小写不匹配 文件及目录匹配判断 -f和!-f用来判断是否存在文件 -d和!-d用来判断是否存在目录 -e和!-e用来判断是否存在文件或目录 -x和!-x用来判断文件是否可执行 flag标记 last - 基本上都用这个Flag。 break - 中止rewirte，不在继续匹配 redirect - 返回临时重定向的HTTP状态302 permanent - 返回永久重定向的HTTP状态301 使用last和break实现URI重写，浏览器地址栏不变。而且两者有细微差别： 使用alias指令必须用last标记 使用proxy_pass指令时，需要使用break标记 last标记在本条rewrite规则执行完毕后，会对其所在server{......}标签重新发起请求，而break标记则在本条规则匹配完成后，终止匹配。]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu服务器启用swap虚拟内存]]></title>
    <url>%2F2018%2F09%2F21%2FUbuntu%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%AF%E7%94%A8swap%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%2Findex.html</url>
    <content type="text"><![CDATA[查看当前虚拟内存： cat /proc/swaps 创建swap文件：sudo dd if=/dev/zero of=swaps bs=512 count=8388616；其中swaps大小为：bs*count=4G 通过mkswap命令把上一步创建的文件做成swap分区：mkswap /path/to/swaps 查看内核参数：cat /proc/sys/vm/swappiness 修改内核参数：sudo vim /etc/sysctl.conf 将 vm.swappiness修改为60（表示100% -60% = 40% 物理内存时启用虚拟内存） 启用分区：sudo swapon /path/to/swaps 修改以使重启启用分区： sudo vim /etc/fstab 添加/path/to/swaps swap swap defaults 0 0 done.]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你真的知道NPM版本管理规范吗]]></title>
    <url>%2F2018%2F09%2F19%2F%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%9F%A5%E9%81%93NPM%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E8%A7%84%E8%8C%83%E5%90%97%2Findex.html</url>
    <content type="text"><![CDATA[NPM Version Management Specification 来源常规的开发，常规的代码，不动如山的CI，突然发生了错误，导致失败，出现以下错误：1Build failed: [BABEL] /xxx/xxx/yyy/.xxx.js: You gave us a visitor for the node type OptionalCallExpression but it's not a valid type 本地调试之，赫然出现了不一样的错误：1Build failed: Cannot find module '@babel/runtime/core-js/object/keys' 观察了一下package.json，含有&quot;babel-runtime&quot;: &quot;^6.9.2&quot;，于是乎开开心心的安装了下@babel/runtime =&gt; npm install @babel/runtime。BOOOOOM！继续报错，寻遍 issue 未发现错误原因以及真正的解决办法，TnT 查看了下框架包，查找了下项目依赖包的依赖包，发现使用了@babel/runtime@7.0.0-beta.41的版本，莫不是版本问题？！换之，修改了下package.json文件如下：12- "babel-runtime": "^6.9.2"+ "@babel/runtime": "^7.0.0-beta.41" 常规rm -rf node_modules &amp;&amp; cnpm install，小段时间的等待之后，发现错误并没有消失，奇了怪了～～ 继续查看依赖包的依赖包，发现它要7.0.0-beta.41，而在我的node_modules/黑洞里的@babel/runtime却安装的是7.0.0版本，Bingo，问题找到了，锁个版本，修改如下： 12- "@babel/runtime": "^7.0.0-beta.41"+ "@babel/runtime": "7.0.0-beta.41" 常规rm -rf node_modules &amp;&amp; cnpm install之后，问题消失了，部署跑CI瞧一下，问题解决。 简单的一个问题，在知道原因之后。如果不知道原因呢？？（此处有个黑人问号） 幸好我知道些npm版本的控制规范，才得已比较早的定位问题并解决之，带着这份小确幸，重新整理了下npm包管理器的版本管理规范（NPM Version Management Specification）。 语义化版本控制规范 SemVerSemVer（Semantic Versioning，语义化版本控制）是Github起草的一个语义化版本号管理模块，它实现了版本号的解析和比较，规范版本号的格式，它解决了依赖地狱的问题。 基本规则语义化版本控制，顾名思义，就是让版本号更具有语义，可以传达出关于软件本身的一些重要信息而不只是简单的一串数字。 基本版本格式1主版本号（Major）.次版本号（Minor）.修订号（Patch） 每个部分都为整数（&gt;=0），按照递增的规则改变。 版本号递增规则 主版本号（Major）：当你做了不兼容的API修改 次版本号（Minor）：当你做了向下兼容的功能性新增 修订号（Patch）：当你做了向下兼容的问题修正 先行版本号及版本编译信息可以加到基本版本格式的后面，作为延伸 先行版本号由首位的连接号”-“、标识符号（由ASCII码的英文数字和连接号标识符[0-9A-Za-z-]组成）、句点”.“组成。如1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。先行版的优先级低于相关联的标准版本 版本编译信息由首位的一个加号和一连串以句点分隔的标识符号（由ASCII码的英文数字和连接号标识符[0-9A-Za-z-]组成）组成。如1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。判断版本优先层级时，版本编译信息可以被忽略 如何比较版本高低判断优先层级时，必须把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较。由左到右依次比较每个标识符号，第一个差异值用来决定优先层级（其中字母连接号以ASCII排序进行比较、其他都相同时栏位多的先行版本号优先级较高）。如：11.0.0-alpha &lt; 1.0.0-alpha.1 &lt; 1.0.0-alpha.beta &lt; 1.0.0-beta &lt; 1.0.0 &lt; 2.0.0 &lt; 2.1.0 &lt; 2.1.1。 范围规则&lt;空&gt;锁定版本号 1.0.0: 锁定了版本只能为1.0.0 &lt;、&lt;=、&gt;、&gt;=、=指定版本范围，甚至可以通过||组合多个比较器 =1.2.7 &lt;1.3.0中包括1.2.7、1.2.8、1.2.99等等，但不包括1.2.6、1.3.0 或1.1.0等等 1.2.7 || &gt;=1.2.9 &lt;2.0.0中包括1.2.7、1.2.9、1.4.6等等，但不包括1.2.8或2.0.0等等 -连字符表示版本号范围，表示的是一个闭区间 1.2.3 - 2.3.4 相当于 &gt;=1.2.3和 &lt;=2.3.4 x、X、*可以替代主版本号.次版本号.修订号三段中任意一段，表示该位置版本号没有限制；另外缺省三段中任意一段与用x、X或*替换该段效果相同 * 相当于 &gt;=0.0.0，表示任何版本号 1.X或1.x 相当于 &gt;=1.0.0 &lt;2.0.0，匹配到主版本号 1.2.* 相当于 &gt;=1.2.0 &lt;1.3.0，匹配到主版本号和次版本号 &quot;&quot;（空字符串） 相当于 * ，即相当于 &gt;=0.0.0 1 相当于 1.x.x，即相当于 &gt;=1.0.0 &lt;2.0.0 1.2 相当于 1.2.x，即相当于 &gt;=1.2.0 &lt;1.3.0 ~允许小版本迭代 如果有缺省值，缺省部分任意迭代； 如果没有缺省值，只允许补丁即修订号（Patch）的迭代 eg.: ~1.2.3：&gt;=1.2.3 &lt;1.3.0 ~1.2：&gt;=1.2.0 &lt; 1.3.0（相当于1.2.x） ~1：&gt;=1.0.0 &lt;2.0.0（相当于1.x） ~0.2.3：&gt;=0.2.3 &lt;0.3.0 ~0.2：&gt;=0.2.0 &lt;0.3.0（相当于0.2.x） ~0：&gt;=0.0.0 &lt;1.0.0（相当于0.x） ~1.2.3-beta.2：&gt;=1.2.3-beta.2 &lt;1.3.0（注意，在1.2.3版本中，允许使用大于等于beta.2的先行版本号，而除1.2.3之外的版本号不允许使用先行版本号，所以此处1.2.3-beta.4是允许的，而1.2.4-beta.2是不允许的） ^允许大版本迭代 允许从左到右的第一段不为0那一版本位+1迭代（左闭右开）； 如果有缺省值，且缺省值之前没有不为0的版本位，则允许缺省值的前一位版本+1迭代 eg.: ^1.2.3：&gt;=1.2.3 &lt;2.0.0 ^0.2.3：&gt;=0.2.3 &lt;0.3.0 ^0.0.3：&gt;=0.0.3 &lt;0.0.4 ^1.2.x：&gt;=1.2.0 &lt;2.0.0 ^0.0.x：&gt;=0.0.0 &lt;0.1.0 ^0.0：&gt;=0.0.0 &lt;0.1.0 ^1.x：&gt;=1.0.0 &lt;2.0.0 ^0.x：&gt;=0.0.0 &lt;1.0.0 ^1.2.3-beta.2：&gt;=1.2.3-beta.2 &lt;2.0.0（注意，在1.2.3版本中，允许使用大于等于beta.2的先行版本号，而除了1.2.3之外的版本号不允许使用先行版本号，所以此处1.2.3-beta.4是允许的，而1.2.4-beta.2是不允许的）； ^0.0.3-beta：&gt;=0.0.3-beta &lt;0.0.4（同上，此处0.0.3-pr.2是允许的） 锁定（控制）版本看到这，聪明的你一定想到了package-lock.json或是yarn.lock。 在npm的版本&gt;=5.1的时候，package-lock.json文件是自动打开的，意味着会自动生成，package-lock.json（官方文档）可以理解为/node_modules文件夹内容的json映射，并能够感知npm的安装/升级/卸载的操作。可以保证在不同的环境下安装的包版本保持一致。听上去很不错哈，实际使用中，大部分它的表现确实不错，可是如上述问题：我手动修改了package.json文件内依赖的版本，package-lock.json就没那么聪明（至少目前是，未来会不会变聪明就不可知了），且不会变化。于是BOOOOOOM～～～～ SO 如果你真的想保证你的包版本在各个环境都是一样的话，请修改下package.json中的依赖，去掉默认前面的^，当然这样的话，你就没法自动享受依赖包小版本的修复了，问题来了，在什么情况下选择哪一种呢？ 在依赖包严格按照版本规范来开发的，你可以使用^来享受包的最新功能和修复。这也是推荐的。 在你不可知或已知依赖包不是那么规范的情况下，或许它在一个小版本（patch）做出不兼容更改（不兼容更改在beta等先行版本中一定[墨菲定律]会发生），那么这个时候，你应该把这个依赖包的版本在package.json上锁住版本，而不应该把它交给package-lock.json来处理 记住一点，绝对不要在生成环境下使用beta等先行版本依赖包，因为如果那是你的私有项目，它会在未来的某一刻坑害了你，如果这是你的共有项目，那么，它一定会在未来的某一刻对你的所有用户做出致命的坑害行为！（beta包就是不负责任的流氓包，玩觉爽就好 ^o^） 最后：rm -rf node_modules/ &amp;&amp; npm install大法在你使用package-lock的情况下，请更换为：rm -rf node_modules &amp;&amp; rm -rf package-lock.json &amp;&amp; npm install。]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器指纹技术]]></title>
    <url>%2F2018%2F09%2F14%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8C%87%E7%BA%B9%E6%8A%80%E6%9C%AF%2Findex.html</url>
    <content type="text"><![CDATA[一些小玩具连接 浏览器基本特征：https://www.whatismybrowser.com/ 当前你使用的浏览器指纹在线预览：https://www.browserleaks.com/canvas 音频指纹在线预览：https://audiofingerprint.openwpm.com/ 综合指纹在线预览：https://panopticlick.eff.org/ 相关文档连接 HTML5 Canvas Fingerprint — Widely Used Unstoppable Web Tracking Technology： https://thehackernews.com/2014/07/html5-canvas-fingerprint-widely-used.html Hardware Fingerprinting Using HTML5：https://arxiv.org/pdf/1503.01408v3.pdf (Cross-)Browser Fingerprinting via OS and Hardware Level Features：http://yinzhicao.org/TrackingFree/crossbrowsertracking_NDSS17.pdf The Web Never Forgets: Persistent Tracking Mechanisms in the Wild：https://securehomes.esat.kuleuven.be/~gacar/persistent/the_web_never_forgets.pdf Pixel Perfect: Fingerprinting Canvas in HTML5：https://hovav.net/ucsd/dist/canvas.pdf The leaking battery A privacy analysis of the HTML5 Battery Status API：https://eprint.iacr.org/2015/616.pdf Online Tracking: A 1-million-site Measurement and Analysis：http://randomwalker.info/publications/OpenWPM_1_million_site_tracking_measurement.pdf Audio fingerprinting being used to track Internet users：http://securityaffairs.co/wordpress/47550/digital-id/audio-fingerprinting-tracking.html How to prevent WebRTC spying in Chrome：https://www.ghacks.net/2014/08/04/deal-webrtc-spying-chrome/]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim 编辑器快捷键]]></title>
    <url>%2F2018%2F09%2F04%2Fvim%E7%BC%96%E8%BE%91%E5%99%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2Findex.html</url>
    <content type="text"><![CDATA[一、vi/vim 配置文件系统的vim配置文件为/etc/vimrc文件，用户级别的配置文件在~/.vimrc文件中，如果没有.vimrc文件，则先创建.vimrc文件1touch ~/.vimrc vimrc部分常用配置如下：12345678910111213141516set sw=4 &quot;自动缩进时，缩进尺寸为4个空格set ts=4 &quot;tab宽度为4个字符set et &quot;编辑时将所有tab替换为空格set smarttab &quot;删除时，一个删除键删除4个空格set selection=inclusive &quot;指定在选择文本时，光标所在位置也属于被选中范围set autoindent &quot;设置自动缩进set number &quot;显示行号set ru &quot;显示vim状态栏，显示行号、列号set hls &quot;搜索时高亮显示被找到的文本set encoding=utf-8 &quot;设置当前字符编码为UTF-8set fileencodings=ucs-bom,utf-8,cp936,gb18030,big5,euc-jp,euc-kr,latin1 &quot;如果文件编码与vim编码不一致，按顺序尝试解码，如果成功则将fileencoding设置为这个值，在文件保存/打开时，自动对文件编解码转换syntax on &quot;打开关键字上色filetype plugin indent on &quot;启动文件类型自动识别、文件类型相关插件、按文件类型的自动缩进 二、vi/vim 常用快捷键vi有三种模式：插入模式、命令模式、底行模式 插入模式：可插入字符，esc退出 命令模式：可进行移动光标，删除字符，复制字符等操作 底行模式：顾名思义，可在末行进行文本匹配、跳转、文本替换等操作 命令： :n 跳转到第n行 :x 保存并退出 :wq 保存并退出 :w 保存 :q 退出编辑器 :q! 退出编辑器，不保存 ctrl + r 恢复上一步被撤销的操作 shift + 方向键 按指定方向跳一个单词 a 在光标右侧添加文本 i 在光标左侧添加文本 A 在行末添加文本 I 在行首添加文本 O 在当前行上添加新行 o 在当前行下添加新行 R 替换编辑光标及后面的文本 J 合并当前行及下一行为一行 h,j,k,l 左、下、上、右 空格,backspace,enter,- 右、左、下一行行首、上一行行首 /xxx 向下搜索字符串xxx ?xxx 向上搜索字符串xxx n 向下搜索前一个搜索动作 N 向上搜索前一个搜索动作 x 删除当前字符 nx 删除光标开始的n字符 dd 删除行 ndd 向下删除当前行在内的n行 u 撤销上一步操作 U 撤销当前行的所有操作 n+ 向下跳n行 n- 向上跳n行 nG 跳转到行号为n的行 G 跳转到文件底 :set number 显示行号 :set nonumber 不显示行号 yy 复制当前行到缓存区 nyy 复制当前行及向下n行到缓存区 yw 复制光标开始到词尾的字符 nyw 复制光标开始的n个单词 y^ 复制光标到行首的内容 y$ 复制光标到行尾的内容 p 在光标后粘贴缓存区的内容 P 在光标前粘贴缓存区的内容 :s/old/new 用new替换当前行中首次出现的old :s/old/new/g 用new替换当前行中所有的old :n,m s/old/new/g 用new替换n到m行中所有的old :%s/old/new/g 用new替换当前文件中所有的old :filetype 查看vim文件类型检测功能是否开启 :set filetype=java 将当前文件类型设置为java，将会按照java文件进行文本高亮 ctrl + n/p 代码补全［插入模式］]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员必读书单（转）]]></title>
    <url>%2F2018%2F08%2F21%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E8%AF%BB%E4%B9%A6%E5%8D%95%EF%BC%88%E8%BD%AC%EF%BC%89%2Findex.html</url>
    <content type="text"><![CDATA[本文把程序员所需掌握的关键知识总结为三大类19个关键概念，然后给出了掌握每个关键概念所需的入门书籍，必读书籍，以及延伸阅读。旨在成为最好最全面的程序员必读书单。前言Reading makes a full man; conference a ready man; and writing an exact man.Francis Bacon优秀的程序员应该具备两方面能力：良好的 程序设计 能力：掌握常用的数据结构和算法（例如链表，栈，堆，队列，排序和散列）；理解计算机科学的核心概念（例如计算机系统结构、操作系统、编译原理和计算机网络）；熟悉至少两门以上编程语言（例如 C++，Java，C#，和 Python）；专业的 软件开发 素养：具备良好的编程实践，能够编写可测试（Testable），可扩展（Extensible），可维护（Maintainable）的代码；把握客户需求，按时交付客户所需要的软件产品；理解现代软件开发过程中的核心概念（例如面向对象程序设计，测试驱动开发，持续集成，和持续交付等等）。和其它能力一样， 程序设计 能力和 软件开发 素养源自项目经验和书本知识。项目经验因人而异（来自不同领域的程序员，项目差异会很大）；但书本知识是相通的——尤其是经典图书，它们都能够拓宽程序员的视野，提高程序员的成长速度。在过去几年的学习和工作中，我阅读了大量的程序设计/软件开发书籍。随着阅读量的增长，我意识到：经典书籍需要不断被重读——每一次重读都会有新的体会；书籍并非读的越多越好——大多数书籍只是经典书籍中的概念延伸（有时甚至是照搬）；意识到这两点之后，我开始思考一个很 功利 的问题：如何从尽可能少的书中，获取尽可能多的关键知识？换句话说：优秀的程序员应该掌握哪些关键概念？哪些书籍来可以帮助程序员掌握这些关键概念？这即是这篇文章的出发点——我试图通过 程序员必读书单 这篇文章来回答上面两个问题。标准进入必读书单之前，我先介绍下书单里的书籍选择标准和领域选择标准。当然你也 点击这里 直接跳转到书单开始阅读。书籍选择标准必读：什么是必读书籍呢？如果学习某项技术有一本书无论如何都不能错过，那么这本书就是必读书籍——例如 Effective Java 于Java， CLR via C# 于C#；注意我没有使用“经典”这个词，因为经典计算机书籍往往和计算机科学联系在一起，而且经典往往需要10年甚至更长的时间进行考验；注重实践，而非理论：所以这个书单不会包含过于原理性的书籍；入门—必读—延伸：必读书籍的问题在于：1. 大多不适合入门；2. 不够全面。考虑到没有入门阅读和延伸阅读的阅读列表是不完整的——所以书单中每个关键概念都会由一本入门书籍，一本必读书籍（有时入门书籍和必读书籍是同一本），和若干延伸阅读书籍所构成。概念选择标准全面：全面覆盖软件开发中重要的概念；通用：适用于每一个程序员，和领域特定方向无关；注重基础，但不过于深入：优秀的程序员需要良好的计算机科学基础，但程序员并没必要掌握过于深入的计算机科学知识。以算法为例，每个程序员都应该掌握排序、链表、栈以及队列这些基本数据结构和算法，但计算几何、线性规划和网络流这些算法可能就不是每个程序员都需要掌握的了；通过这几个标准，我把程序员应掌握的关键概念分为程序设计，软件开发，以及个人成长三大类，每一大类均由若干关键概念组成。快速通道自从开博以来，经常会有朋友在论坛，微博，和QQ上提问学习X技术读什么书合适（例如：学习Java读什么书合适？如何学习程序设计？）所以我在这里列出了一个“快速通道”——把常见的问题集中在一起，点击问题，即可直接进入答案。（当然，如果你把本文从头读到尾帮助会更大 :-)）如何学习计算机基础知识？如何学习 C 语言？如何学习 C++？如何学习 Java？如何学习 C#？如何学习 JavaScript？如何学习 Python？如何加深对编程语言的理解？如何学习程序设计技巧？如何学习算法？如何高效的调试程序？如何掌握良好的编程实践？如何学习面向对象程序设计？如何对代码进行重构？如何更好的进行软件测试？如何管理软件团队/软件项目？如何成为一名更专业的程序员？程序员如何学习设计？程序员如何进行职业规划？如何提高自己的思维能力？如何进行高效求职面试？如何提高自己的英语写作能力？程序员必读书单入门书籍程序设计：基础理论 ： 编码：隐匿在计算机软硬件背后的语言编程语言 ：C ： C 和指针C++ ： C++ 程序设计原理与实践Java ： Java 核心技术（第9版）C# ： 精通 C#（第6版）JavaScript ： JavaScript DOM编程艺术（第2版）Python ： Python 基础教程（第二版）编程语言理论 ： 编程语言实现模式程序设计 ： 程序设计方法算法与数据结构 ： 算法（第4版）程序调试 ： 调试九法——软硬件错误的排查之道软件开发：编程实践 ： 程序设计实践面向对象程序设计 ： Head First设计模式重构 ： 重构软件测试 ： How to Break Software项目管理 ： 极客与团队专业开发 ： 程序员修炼之道：从小工到专家大师之言 ： 奇思妙想：15 位计算机天才及其重大发现界面设计 ： 写给大家看的设计书交互设计 ： 通用设计法则个人成长：职业规划 ： 软件开发者路线图思维方式 ： 程序员的思维修炼：开发认知潜能的九堂课求职面试 ： 金领简历：敲开苹果微软谷歌的大门英语写作 ： The Only Grammar Book You’ll Ever Need必读书籍程序设计：基础理论 ： 深入理解计算机系统（第 2 版）编程语言 ：C ： C 程序设计语言（第 2 版）C++ ： C++程序设计语言（第 4 版）Java ： Effective Java（第 2 版）C# ： CLR via C#（第 4 版）JavaScript ： JavaScript 语言精粹Python ： Python参考手册（第 4 版）编程语言理论 ： 程序设计语言——实践之路（第 3 版）程序设计 ： 计算机程序的构造与解释（第 2 版）算法与数据结构 ： 编程珠玑（第 2 版）程序调试 ： 调试九法——软硬件错误的排查之道软件开发：编程实践 ： 代码大全（第 2 版）面向对象程序设计 ： 设计模式重构 ： 修改代码的艺术软件测试 ： xUnit Test Patterns项目管理 ： 人月神话专业开发 ： 程序员职业素养大师之言 ： 编程人生：15 位软件先驱访谈录界面设计 ： 认知与设计：理解UI设计准则（第 2 版）交互设计 ： 交互设计精髓（第 3 版）个人成长：职业规划 ： 软件开发者路线图思维方式 ： 如何把事情做到最好求职面试 ： 程序员面试金典（第 5 版）英语写作 ： 风格的要素这个阅读列表覆盖了软件开发各个关键领域的入门书籍和必读书籍，我相信它可以满足绝大多数程序员的需求，无论你是初学者，还是进阶者，都可以从中获益：基础理论 包括了程序员应该掌握的计算机基础知识；编程语言 对软件开发至关重要，我选择了 C ， C++ ， Java ， C# ， Python ，和 JavaScript 这六门 主流编程语言 进行介绍，如果想进一步理解编程语言，可以阅读 编程语言理论 里的书目；在理解编程语言的基础上，优秀的程序员还应该了解各种 程序设计 技巧，熟悉基本的 算法数据结构 ，并且能够高效的进行 程序调试 。良好的程序设计能力是成为优秀程序员的前提，但软件开发知识也是必不可少的：优秀的程序员应具备良好的 编程实践 ，知道如何利用 面向对象 ， 重构 ，和 软件测试 编写可复用，可扩展，可维护的代码，并具备软件 项目管理 知识和 专业开发 素养；就像我们可以从名人传记里学习名人的成功经验，程序员也可以通过追随优秀程序员的足迹使自己少走弯路。 大师之言 包含一系列对大师程序员/计算机科学家的访谈，任何程序员都可以从中获益良多；为了打造用户满意的软件产品，程序员应当掌握一定的 界面设计 知识和 交互设计 知识（是的，这些工作应该交给UI和UX，但如果你想独自打造一个产品呢？）；专业程序员应当对自己进行 职业规划 ，并熟悉程序员 求职面试 的流程，以便在职业道路上越走越远；软件开发是一项需要不断学习的技能，学习 思维方式 可以有效的提升学习能力和学习效率；软件开发是一项国际化的工作，为了让更多的人了解你的代码（工作），良好的 英语写作 能力必不可少。尽管我尽可能的去完善这个书单，但受限于我的个人经历，这个书单难免会有所偏颇。所以如果你有不同的意见，或者认为这个书单漏掉了某些重要书籍，请在评论中指出，我会及时更新。:-)程序设计1. 基础理论 编码：隐匿在计算机软硬件背后的语言 这本书其实不应该叫编码——它更应该叫“Petzold教你造计算机”——作者 Charles Petzold 创造性的以编码为主题，从电报机和手电筒讲到数字电路，然后利用 数字电路 中的逻辑门构造出 加法器 和 触发器 ，最后构造出一个完整的 存储程序计算机 。不要被这些电路概念吓到—— 编码 使用大量形象贴切的类比简化了这些概念，使其成为最精彩最通俗易懂的计算机入门读物。 深入理解计算机系统（第2版） 这本书的全名是：Computer Systems：A Programmer’s Perspective（所以它又被称为 CSAPP），我个人习惯把它翻译为程序员所需了解的计算机系统知识，尽管土了些，但更名副其实。 深入理解计算机系统 是我读过的最优秀的计算机系统导论型作品，它创造性的把操作系统，计算机组成结构，数字电路，以及编译原理这些计算机基础学科中的核心概念汇集在一起，从而覆盖了指令集体系架构，汇编语言，代码优化，计算机存储体系架构，链接，装载，进程，以及虚拟内存这些程序员所需了解的关键计算机系统知识。如果想打下扎实的计算机基础又不想把操作系统计算机结构编译原理这些书统统读一遍，阅读 深入理解计算机系统 是最有效率的方式。延伸阅读：世界是数字的 ： K&amp;R 中的 K（ Brian Kernighan ）的近作，这本书源自 Brian 在普林斯顿大学所教授的计算机基础课程，以通俗易懂的方式讲述了现代人所应了解的计算机知识和网络知识；图灵的秘密：他的生平、思想及论文解读 ： Charles Petzold 的另一部作品，这本书以图灵的论文论可计算数及其在判定问题上的应用（ On Computable Numbers, with an Application to the Entscheidungsproblem ）为主题，阐述了图灵机（现代计算机的始祖）的构造，原理，以及应用。计算机系统概论（第2版） ：另一部优秀的计算机系统导论型作品，和 深入理解计算机系统 不同，这本书采用自下而上的方式，从二进制，和数字逻辑这些底层知识一步步过渡到高级编程语言（C），从而以另一种方式理解计算机系统。2. 编程语言编程语言是程序员必不可少的日常工具。工欲善其事，必先利其器。我在这里给出了 C，C++，Java，C#，JavaScript，和Python 这六种 常用编程语言 的书单（我个人不熟悉 Objective-C 和 PHP，因此它们不在其中）。需要注意的是：我在这里给出的是编程语言（Programming Language）书籍，而非编程平台（Programming Platform）书籍。以 Java 为例， Effective Java 属于编程语言书籍，而 Android编程权威指南 就属于编程平台书籍。C 忘记谭浩强那本糟糕不堪的 C 程序设计， C和指针 才是 C 语言的最佳入门书籍。它详细但又不失简练的介绍了 C 语言以及 C 标准库的方方面面。对于C语言初学者，最难的概念不仅仅是指针和数组，还有指向数组的指针和指向指针的指针。 C和指针 花了大量的篇幅和图示来把这些难懂但重要的概念讲的清清楚楚，这也是我推荐它作为C语言入门读物的原因。 尽管 C程序设计语言 是二十多年前的书籍，但它仍然是C语言——以及计算机科学中最重要的书籍之一，它的重要性不仅仅在于它用清晰的语言和简练的代码描述了 C 语言全貌，而且在于它为之后的计算机书籍——尤其是编程语言书籍树立了新的标杆。以至于在很多计算机书籍的扉页，都会有“感谢 Kernighan 教会我写作”这样的字样。延伸阅读：C 专家编程 ：不要被标题中的“专家”吓到，这实际是一本很轻松的书籍，它既包含了大量 C 语言技术细节和编程技巧，也包含了很多有趣的编程轶事；C 陷阱与缺陷 ：书如其名，这本书介绍了 C 语言中常见的坑和一些稀奇古怪的编程“技巧”，不少刁钻的C语言面试题都源自这本小册子；C 语言参考手册 ：全面且权威的 C 语言参考手册，而且覆盖 C99，如果你打算成为 C 语言专家，那么这本书不可错过；C 标准库 ：给出了15个C标准库的设计思路，实现代码，以及测试代码，配合 C 程序设计语言 阅读效果更佳；C 语言接口与实现 ：这本书展示了如何使用C语言实现可复用的数据结构，其中包含大量 C 语言高级技巧，以至于 Amazon 上排行第一的评论是 “Probably the best advanced C book in existance”，而排行第二的评论则是 “By far the most advanced C book I read”。C++ 作为C++的发明者，没有人能比 Bjarne Stroustrup 更理解C++。Bjarne在Texas A&amp;M大学任教时使用C++为大学新生讲授编程，从而就有了 C++ 程序设计原理与实践 这本书——它面向编程初学者，既包含 C++ 教程，也包含大量程序设计原则。它不但是我读过最好的C++入门书，也是我读过最好的编程入门书。比较有趣的是， C++ 程序设计原理与实践 直到全书过半都没有出现指针，我想这可能是Bjarne为了证明不学C也可以学好C++吧。 同样是 Bjarne Stroustrup 的作品， C++ 程序设计语言 是 C++ 最权威且最全面 的书籍。第4版相对于之前的版本进行了全面的更新，覆盖了第二新的C++ 11标准，并砍掉了部分过时的内容。延伸阅读：A Tour of C++ ：如果你觉得 C++程序设计语言 过于庞大，但你又想快速的浏览一遍新版 C++ 的语言特色，那么可以试试这本小红书；C++ 语言的设计与演化 ：C++ 的“历史书”，讲述了 C++ 是如何一步一步从 C with Classes 走到如今这一步，以及 C++ 语言特性背后的故事；C++ 标准库（第2版） ：相对于其它语言的标准库，C++ 标准库虽然强大，但学习曲线十分陡峭，这本书是学习 C++ 标准库有力的补充；深度探索 C++ 对象模型 ：这本书系统的讲解了 C++ 是如何以最小的性能代价实现对象模型，很多C++面试题（包括被问烂的虚函数指针）都可以在这本书里找到答案；Effective C++ 和 More Effective C++ ：由于 C++ 的特性实在繁杂，因此很容易就掉到坑里。Effective 系列既讲述了 C++ 的良好编程实践，也包含C++的使用误区，从而帮你绕过这些坑。Java 平心而论 Java 核心技术 （即Core Java）并不算是一本特别出色的书籍：示例代码不够严谨，充斥着很多与C/C++的比较，语言也不够简洁——问题在于Java并没有一本很出色的入门书籍，与同类型的 Java 编程思想 相比， Java 核心技术 至少做到了废话不多，与时俱进（ Java 编程思想 还停留在 Java 6之前），矮子里面选将军， Java 核心技术 算不错了。 尽管 Java 没有什么出色的入门书籍，但这不代表 Java 没有出色的必读书籍。 Effective Java 是我读过的最好的编程书籍之一，它包含大量的优秀Java编程实践，并对泛型和并发这两个充满陷阱的 Java 特性给出了充满洞察力的建议，以至于 Java 之父 James Gosling 为这本书作序：“我很希望 10 年前就拥有这本书。可能有人认为我不需要任何 Java 方面的书籍，但是我需要这本书。”延伸阅读：深入理解 Java 虚拟机（第2版） ：非常优秀且难得的国产佳作，系统的介绍了 Java 虚拟机和相关工具，并给出了一些调优建议；Java 程序员修炼之道 ：在这本书之前，并没有一本 Java 书籍系统详细的介绍 Java 7 的新特性（例如新的垃圾收集器，try using 结构和 invokedynamic 指令），这本书填补了这个空白；Java 并发编程实践 ：系统全面的介绍了 Java 的并发，如何设计支持并发的数据结构，以及如何编写正确的并发程序；Java Puzzlers ：包含了大量的 Java 陷阱——以至于读这本书时我说的最多的一个词就是 WTF，这本书的意义在于它是一个 反模式 大全， Effective Java 告诉你如何写好的 Java 程序，而 Java Puzzlers 则告诉你糟糕的 Java 程序是什么样子。更有意思的是，这两本书的作者都是 Joshua Bloch 。C# 可能你会疑问我为什么会推荐这本接近 1200 页的“巨著”用作 C# 入门，这是我的答案：C# 的语言特性非常丰富，很难用简短的篇幅概括这些特性；精通 C# 之所以有近 1200 页的篇幅，是因为它不但全面介绍了 C# 语言，而且还覆盖了 ADO.NET，WCF，WF，WPF，以及 ASP.NET 这些 .Net 框架。你可以把这本书视为两本书——一本 500 多页的 C# 语言教程和一本 600 多页的 .Net 平台框架快速上手手册。尽管标题带有“精通”两字， 精通 C# 实际上是一本面向初学者的C#书籍，你甚至不需要太多编程知识，就可以读懂它。 CLR via C# 是C#/.Net最重要的书籍，没有之一。它全面介绍了 .Net 的基石—— CLR 的运行原理，以及构建于 CLR 之上的 C# 类型系统，运行时关系，泛型，以及线程/并行等高级内容。任何一个以 C# 为工作内容的程序员都应该阅读此书。延伸阅读：深入理解 C#（第 3 版） ：C# 进阶必读，这本书偏重于C#的语言特性，它系统的介绍了C#从1.0到C# 4.0的语言特性演化，并展示了如何利用C#的语言特性编写优雅的程序;.NET设计规范（第 2 版） ：C# 专业 程序员必读，从变量命名规范讲到类型系统设计原则，这本书提供了一套完整的.Net编程规范，使得程序员可以编写出一致，严谨的代码，C# 5.0 权威指南 ：来自 O’Reilly 的 C# 参考手册，严谨的介绍了 C# 语法，使用，以及核心类库，C#程序员案头必备；LINQ to Objects Using C# 4.0 和 Async in C# 5.0 ：LINQ 和 async 分别是 .Net 3.5 和 .Net 4.5 中所引入的最重要的语言特性，所以我认为有必要在它们上面花点功夫——这两本书是介绍 LINQ 和 async 编程的最佳读物。JavaScript 尽管JavaScript现在可以做到客户端服务器端通吃，尽管 JQuery 之类的前端框架使得一些人可以不懂JavaScript也可以编程，但我还是认为学习JavaScript从HTML DOM开始最为适合，因为这是JavaScript设计的初衷。 JavaScript DOM编程艺术 系统的介绍了如何使用JavaScript，HTML，以及 CSS 创建可用的 Web 页面，是一本前端入门佳作。 JavaScript语言包含大量的陷阱和误区，但它却又有一些相当不错的特性，这也是为什么 Douglas Crockford 称JavaScript为 世界上最被误解的语言 ，并编写了 JavaScript 语言精粹 一书来帮助前端开发者绕开JavaScript中的陷阱。和同类书籍不同， JavaScript 语言精粹 用精炼的语言讲解了JavaScript语言中好的那部分（例如闭包，函数是头等对象，以及对象字面量），并建议读者 不要 使用其它不好的部分（例如混乱的类型转换，默认全局命名空间，以及 奇葩的相等判断符 ），毕竟，用糟糕的特性编写出来的程序往往也是糟糕的。延伸阅读：JavaScript 高级程序设计（第 3 版） ：详尽且深入的介绍了Javascript语言，DOM，以及Ajax，并针对HTML5做了对应更新；JavaScript 权威指南（第 6 版） ：这本书的第5版曾被前端专家 Douglas Crockford 称之为“唯一靠谱的 JavaScript 书”。相对于 JavaScript高级程序设计 ， JavaScript 权威指南 更像是一本案头参考书，当然如果你感兴趣也可以从头读到尾；编写可维护的 JavaScript ：书如其名，这本书给出了大量的优秀 JavaScript 编程实践，使得程序员编写出健壮且易于维护的 JavaScript 代码；JavaScript 异步编程 ：和常见的支持并发的编程语言（例如 Java 和 C#）不同，JavaScript 本身是 单线程 的，因此不能把其它语言处理并发的方式照搬到 JavaScript。 JavaScript 异步编程 系统的介绍了JavaScript 中的并发原理，并阐述了如何使用 Promise、Deferred 以及 Async.js 编写出简洁高效的异步程序。Python Python 的入门书籍很多，而且据说质量大多不错，我推荐 Python 基础教程 的原因是因为它是我的Python入门读物——简洁，全面，代码质量很不错，而且有几个很有趣的课后作业，使得我可以快速上手。这里顺便多说一句，不要用 Python 学习手册 作为Python入门——它的废话实在太多，你能想象它用了15页的篇幅去讲解if语句吗？尽管 O’Reilly 出了很多经典编程书，但这本 Python 学习手册 绝对不在其中。 权威且实用 Python 书籍，覆盖 Python 2和 Python 3。尽管它名为参考手册，但 Python 参考手册 在 Python 语法和标准库基础之上对其实现机制也给出了深入的讲解，不容错过。延伸阅读：Python 袖珍指南（第 5 版） ：实用且便携的 Python 参考手册，我会说我在飞机上写程序时用的就是它么 -_-#；Python Cookbook（第 3 版） ：非常好的 Python 进阶读物，包含各种常用场景下的 Python 代码，使得读者可以写出更加 Pythonic 的代码；Python 编程实战：运用设计模式、并发和程序库创建高质量程序 ：Python 高级读物，针对 Python 3，2014 年的 Jolt 大奖图书 ，不可错过；Python 源码剖析 ：少见的国产精品，这本书以 Python 2.5 为例，从源代码出发，一步步分析了 CPython 是如何实现类型，控制流，函数/方法的声明与调用，类型以及装饰器等 Python 核心概念，读过之后会大大加深对 Python 的理解。尽管这本书有些过时，但我们仍然可以按照它分析源代码的方式来分析新版Python。3. 编程语言理论 大多数程序员并不需要从头编写一个编译器或解释器，因此 龙书（编译原理） 就显得过于重量级；然而多数程序员还是需要解析文本，处理配置文件，或者写一个小语言， 编程语言实现模式 很好的满足了这个需求。它把常用的文本解析/代码生成方法组织成一个个模式，并为每个模式给出了实例和应用场景。这本书既会提高你的动手能力，也会加深你对编程语言的理解。Python 发明者 Guido van Rossum 甚至为这本书给出了 “Throw away your compiler theory book!” 这样的超高评价。 程序员每天都要和编程语言打交道，但是思考编程语言为什么会被设计成这个样子的程序员并不多， 程序设计语言——实践之路 完美的回答了这个问题。这本书从编程语言的解析和运行开始讲起，系统了介绍了命名空间，作用域，控制流，数据类型以及方法（控制抽象）这些程序设计语言的核心概念，然后展示了这些概念是如何被应用到过程式语言，面向对象语言，函数式语言，脚本式，逻辑编程语言以及并发编程语言这些具有不同编程范式的编程语言之上。这本书或极大的拓宽你的视野——无论你使用什么编程语言，都会从这本书中获益良多。理解这一本书，胜过学习十门新的编程语言。延伸阅读：七周七语言：理解多种编程范型 ：尽管我们在日常工作中可能只使用两三门编程语言，但是了解其它编程语言范式是很重要的。 七周七语言 一书用精简的篇幅介绍了 Ruby，Io，Prolog，Scala，Erlang，Clojure，和 Haskell 这七种具有不同编程范式的语言——是的，你没法通过这本书变成这七种语言的专家，但你的视野会得到极大的拓宽；自制编程语言 ：另一本优秀的编译原理作品， 自制编程语言 通过从零开始制作一门无类型语言 Crowbar 和一门静态类型语言 Diksam，把类型系统，垃圾回收，和代码生成等编程语言的关键概念讲的清清楚楚；计算的本质：深入剖析程序和计算机 ：披着 Ruby 外衣的 计算理论 入门书籍，使你对编程语言的理解更上一层楼。4. 程序设计 现代编程语言的语法大多很繁杂，初学者使用这些语言学习编程会导致花大量的时间在编程语言语法（诸如指针，引用和类型定义）而不是程序设计方法（诸如数据抽象和过程抽象）之上。 程序设计方法 解决了这个问题——它专注于程序设计方法，使得读者无需把大量时间花在编程语言上。这本书还有一个与之配套的教学开发环境 DrScheme ，这个环境会根据读者的程度变换编程语言的深度，使得读者可以始终把注意力集中在程序设计方法上。我个人很奇怪 程序设计方法 这样的佳作为什么会绝版，而谭浩强C语言这样的垃圾却大行其道——好在是程序设计方法 第二版 已经被免费发布在网上。 计算机程序的构造与解释 是另一本被国内大学忽视（至少在我本科时很少有人知道这本书）的教材，这本书和 程序设计方法 有很多共同点——都使用 Scheme )作为教学语言；都专注于程序设计方法而非编程语言本身；都拥有相当出色的课后题。相对于 程序设计方法 ， 计算机程序的构造与解释 要更加深入程序设计的本质（过程抽象，数据抽象，以及元语言抽象），以至于 Google 技术总监 Peter Norvig 给了这本书 超高的评价 。延伸阅读：编程原本 ： STL 作者的关于程序设计方法佳作——他把关系代数和群论引入编程之中，试图为程序设计提供一个坚实的理论基础，从而构建出更加稳固的软件。这本书是 程序设计方法 和 计算机程序的构造与解释 的绝好补充——前者使用函数式语言（Scheme）讲授程序设计，而 编程原本 则使用命令式语言（C++）;元素模式 ： 设计模式 总结了 面向对象程序设计 中的模式，而 元素模式 这本书分析了 程序设计 中的常见模式的本质，阅读这本书会让你对程序设计有更深的理解；The Science of Programming ：会编程的人很多，但能够编写正确程序的人就少多了。 The Science of Programming 通过 前条件——不变式——后条件 以及逻辑谓词演算，为编写正确程序提供了强有力的理论基础，然后这本书通过实例阐述了如何应用这些理论到具体程序上。任何一个想大幅提高开发效率的程序员都应阅读此书。5. 算法与数据结构 我在 算法学习之路 一文中提到我的算法入门教材是 数据结构与算法分析：C语言描述 ，我曾经认为它是最好的算法入门教材，但自从我读到 Sedgewick 的 算法 之后我就改变了观点——这本 算法 才是最好的算法入门教材：使用更为容易的Java语言作为教学语言；覆盖所有常用的数据结构和算法，并均给出其完整实现；包含大量的图示用于可视化算法——事实上这是我读过的图示最为丰富形象的书籍，这也是我称其为最好的算法入门书籍的原因。 编程珠玑（第 2 版） 是一本少见的实践型算法书籍——它并非一一介绍数据结构/算法的教材，而是实践性极强的算法应用手册。作者（ Jon Bentley ）从他多年的实际经验精选出一些有趣而又实用的问题，然后展示了他解决这些问题的过程（分析问题，选择合适的算法，解决问题，以及验证答案）。任何程序员都可以从中获益。延伸阅读：编程珠玑（续） ：严格来说这本书并非 编程珠玑 的续作，而是一本类似于番外篇的编程技巧/实践手册；它不像 编程珠玑 那般重视算法的应用，而是全面覆盖了程序员所需的能力；算法导论（第 3 版） ：尽管我在这边文章开头提到会尽量避免理论性的书籍，但没有 算法导论 的算法阅读列表是不完整的，我想这本书就不需要我多介绍了； :-)算法设计与分析基础（第 3 版） ：侧重于算法设计，这本书创新的把常见算法分为分治，减治，变治三大类，并覆盖了动态规划，回溯，以及分支定界等高级算法设计方法，属于算法设计的入门佳作。6. 程序调试 一个让非编程从业人员惊讶的事实是程序员的绝大多时间都花在调试上，而不是写程序上，以至于 Bob 大叔 把 调试时间占工作时间的比例 作为衡量程序员开发能力的标准。 调试九法——软硬件错误的排查之道 既是调试领域的入门作品，也是必读经典之作。 调试九法 的作者是一个具有丰富实战经验的硬件工程师，他把他多年的调试经验总结成九条调试法则，并对每一条法则都给对应的实际案例。任何程序员都应通过阅读这本书改善调试效率，即便是非程序员，也可以从这本书中学到系统解决问题的方法。延伸阅读：Writing Solid Code ：最好的调试是不调试—— Writing Solid Code 介绍了断言，设计清晰的 API，以及单步代码等技巧，用于编写健壮的代码，减少调试的时间；软件调试的艺术 ：调试工具书——这本书详细的介绍了常见的调试器工具，并通过具体案例展示了它们的使用技巧；软件开发1. 编程实践 Brian Kernighan 是这个星球上最好的计算机书籍作者：从上古时期的 Software Tools ，到早期的 Unix编程环境 和 C 程序设计语言 ，再到这本 程序设计实践 ，每本书都是必读之作。尽管程序设计实践只有短短 200 余页，但它使用精炼的代码和简要的原则覆盖了程序设计的所有关键概念（包括编程风格，算法与数据结构，API 设计，调试，测试，优化，移植，以及领域特定语言等概念）。如果你想快速掌握良好的编程实践，或者你觉着900多页的 代码大全 过于沉重，那么程序设计实践是你的不二之选。我第一次读这本书就被它简洁的语言和优雅的代码所吸引，以至于读研时我买了三本程序设计实践——一本放在学校实验室，一本放在宿舍，一本随身携带阅读。我想我至少把它读了十遍以上——每一次都有新的收获。 无论在哪个版本的程序员必读书单， 代码大全 都会高居首位。和其它程序设计书籍不同， 代码大全 用通俗清晰的语言覆盖了软件构建（Software Construction）中各个层次上 所有 的重要概念——从变量命名到类型设计，从控制循环到代码结构，从测试和调试到构建和集成， 代码大全 可谓无所不包，你可以把这本书看作为程序员的一站式（Once and for all）阅读手册。更珍贵的是， 代码大全 在每一章末尾都给出了价值很高的参考书目（参考我之前的 如何阅读书籍 一文），如果你是一个初出茅庐的程序员， 代码大全 是绝好的阅读起点。延伸阅读：编写可读代码的艺术 ：专注于代码可读性（Code Readability），这本书来自 Google 的两位工程师对 Google Code Readability 的总结。它给出了大量命名，注释，代码结构，以及 API 设计等日常编码的最佳实践，并包含了很多看似细微但却可以显著提升代码可读性的编程技巧。这本书的翻译还不错，但如果你想体会书中的英语幽默（例如Tyrannosaurus——Stegosaurus——Thesaurus），建议阅读它的 英文影印版 ；卓有成效的程序员 ：专注于生产效率（Productivity），它既包含源自作者多年经验的高生产率原则，也包含大量的提高生产率的小工具，每个追求高生产率的程序员都应该阅读这本书；UNIX编程艺术 ：专注于程序设计哲学，这本书首先总结出包括模块化，清晰化，可组合，可分离等17个Unix程序设计哲学，接下来通过 Unix 历史以及各种 Unix 编程工具展示了这些原则的应用。尽管个人觉的这本书有些过度拔高 Unix 且过度贬低 Windows 和 M$，但书中的 Unix 设计哲学非常值得借鉴。2. 面向对象程序设计 无论是在 Amazon 还是在 Google 上搜索设计模式相关书籍， Head First 设计模式 都会排在首位——它使用风趣的语言和诙谐的图示讲述了观察者，装饰者，抽象工厂，和单例等关键设计模式，使得初学者可以迅速的理解并掌握设计模式。 Head First 设计模式 在Amazon上 好评如潮 ，就连设计模式原书作者 Erich Gamma 都对它给出了很高的评价。需要注意， Head First设计模式 是非常好的设计模式入门书，但 千万不要 把这本书作为学习设计模式的唯一的书——是的，Head First 设计模式拥有风趣的语言和诙谐的例子，但它既缺乏 实际 的工程范例，也没有给出设计模式的应用/适用场景。我个人建议是在读过这本书之后立即阅读 “四人帮” )的 设计模式 或 Bob 大叔 的 敏捷软件开发 ，以便理解设计模式在实际中的应用。 设计模式 作为设计模式领域的开山之作，Erich Gamma，Richard Helm，Ralph Johnson等四位作者将各个领域面向对象程序开发的经验总结成三大类23种模式，并给出了每个模式的使用场景，变体，不足，以及如何克服这些不足。这本书行文严谨紧凑（四位作者都是PhD），并且代码源自实际项目，属于设计模式领域的必读之作。需要注意： 设计模式 不适合 初学者阅读——它更像是一篇博士论文而非技术书籍，加上它的范例都具有很强的领域背景（诸如 GUI 窗口系统和富文本编辑器），缺乏实际经验的程序员很难理解这本书。延伸阅读：敏捷软件开发（原则模式与实践） ：尽管标题带有“敏捷”，但这本书实际是一本面向对象程序设计读物—— Bob 大叔 通过丰富的例子讲解设计模式的应用和 SOLID 面向对象设计原则 )，如果你觉着 设计模式 过于晦涩，那么你完全可以从这本书开始学习。这本书使用Java作为讲解语言，它也有对应的 C# 版本 ；代码整洁之道 ：同样是 Bob 大叔 的作品，这本书教导读者使用面向对象+敏捷开发原则编写清晰可维护的代码；企业应用架构模式 ：这本书专注于架构，作者 Martin Fowler 针对企业应用的特点（诸如持久化数据，多人访问，操作数据的界面以及复杂的业务逻辑），总结出若干企业架构模式，以便程序员构建强大且可扩展的企业应用。3. 重构 任何产品代码都不是一蹴而就，而是在反复不断的修改中进化而来。 重构 正是这样一本介绍如何改进代码的书籍——如何在保持代码行为的基础上，提升代码的质量（这也是重构的定义）。我见过很多程序员，他们经常声称自己在重构代码，但他们实际只做了第二步（提升代码的质量），却没有保证第一步（保持代码行为），因此他们所谓的重构往往会适得其反——破坏现有代码或是引入新 bug。这也是我推荐 重构 这本书的原因——它既介绍糟糕代码的特征（Bad smell）和改进代码的方法，也给出了重构的完整流程——1. 编写单元测试保持（Preserve）程序行为；2. 重构代码；3. 保证单元测试通过。 重构 还引入了一套重构术语（诸如封装字段，内联方法，和字段上移），以便程序员之间交流。只有理解了这三个方面，才能算是理解重构。 这里再重复一遍重构的定义——在保持代码行为的基础上，提升代码的质量。 重构 专注于第二步，即如何提升代码的质量，而 修改代码的艺术 专注于第一步，即如何保持代码的行为。提升代码质量并不困难，但保持代码行为就难多了，尤其是对没有测试的遗留代码（Legacy Code）而言——你需要首先引入测试，但遗留代码往往可测试性（Testability）很差，这时你就需要把代码变的可测试。 修改代码的艺术 包含大量的实用建议，用来把代码变的可测试（Testable），从而使重构变为可能，使提高代码质量变为可能。延伸阅读：重构与模式 ：这本书的中文书名存在误导，它的原书书名是 Refactoring to Patterns——通过重构，把模式引入代码。这本书阐述了重构和设计模式之间的关系，使得程序员可以在更高的层次上思考重构，进行重构。4. 软件测试 关于软件测试的书籍很多，但很少有一本测试书籍能像 How to Break Software 这般既有趣又实用。不同于传统的软件测试书籍（往往空话连篇，无法直接应用）， How to Break Software 非常实际——它从程序员的心理出发，分析软件错误/Bug最可能产生的路径，然后针对这些路径进行 残酷 的测试，以保证软件质量。我在第一次阅读这本书时大呼作者太过“残忍”——连这些刁钻诡异的测试招数都能想出来。但这种毫不留情（Relentless）的测试风格正是每个专业程序员所应具备的心态。注意：如果你是一个测试工程师，那么在阅读这本书前请三思——因为阅读它之后你会让你身边的程序员苦不堪言，甚至连掐死你的心都有 :-D。 How to Break Software 注重黑盒测试，而这本 xUnit Test Patterns 则注重白盒测试。正如书名所示， xUnit Test Patterns 覆盖了单元测试的每个方面：从如何编写良好的单元测试，到如何设计可测试（Testable）的软件，再到如何重构测试——可以把它看作为单元测试的百科全书。延伸阅读：Practical Unit Testing with JUnit and Mockito ：尽管 xUnit Test Patterns 覆盖了单元测试的方方面面，但它的问题在于不够与时俱进（07 年出版）。 Practical Unit Testing 弥补了这个缺陷——它详细介绍了如何通过测试框架 JUnit 和 Mock 框架 Mockito 编写良好的单元测试，并给出了大量优秀单元测试的原则；单元测试的艺术（第 2 版） ：可以把这本书看作为前一本书的.Net版，适合.Net程序员；Google 软件测试之道 ：这本书详细介绍了 Google 如何测试软件——包括Google的软件测试流程以及Google软件测试工程师的日常工作/职业发展。需要注意的是：这本书中的测试流程在国内很可能行不通（国内企业缺乏像Google那般强大的基础设施（Infrastructure）），但它至少可以让国内企业有一个可以效仿的目标；探索式软件测试 ： James Whittaker 的另一本测试著作，不同于传统的黑盒/白盒测试，这本书创造性的把测试比喻为“探索”（Exploration），然后把不同的探索方式对应到不同的测试方式上，以便尽早发现更多的软件错误/Bug。5. 项目管理 很多程序员都向往成为横扫千军（One-man Army）式的“编程英雄”，但卓越的软件并非一人之力，而是由团队合力而成。 极客与团队 就是这样一本写给程序员的如何在团队中工作的绝好书籍，它围绕着 HRT 三大原则（Humility 谦逊，Respect 尊重，和 Trust 信任），系统的介绍了如何融入团队，如何打造优秀的团队，如何领导团队，以及如何应对团队中的害群之马（Poisonous People）。这本书实用性极强，以至于 Python 之父 Guido van Rossum 都盛赞这本书 “说出了我一直在做但总结不出来的东西”。 尽管 人月神话 成书于 40 年前，但它仍是软件项目管理最重要的书籍。 人月神话 源自作者 Fred Brooks 领导并完成 System/360 和 OS/360 这两个即是放到现在也是巨型软件项目的里程碑项目的经验总结。它覆盖了软件项目各个方面的关键概念：从工期管理（ Brooks定律 ）到团队建设（ 外科团队 ），从程序设计（编程的本质是使用正确的数据结构）到架构设计（ 概念完整性 ），从原型设计（Plan to Throw one away）到团队交流（形式化文档+会议）。令人惊讶的是，即便40年之后， 人月神话 中的关键概念（包括焦油坑， Brooks定律 ， 概念完整性 ， 外科团队 ， 第二版效应 等等）依然适用，而软件开发的 核心复杂度 仍然没有得到解决（ 没有银弹 ）。延伸阅读：人件（原书第3版） ：从人的角度分析软件项目。 人件 从雇佣正确的人，创建健康的工作环境，以及打造高效的开发团队等角度阐述了如何改善人，从而改善软件项目；门后的秘密：卓越管理的故事 ：这本书生动的再现了软件项目管理工作的场景，并给出了各种实用管理技巧，如果你有意转向管理岗位，这本书不容错过；大教堂与集市 ：这本书从黑客的历史说起，系统而又风趣的讲述了开源运动的理论和实践，以及开源软件项目是如何运作并发展的。了解开源，从这本书开始。6. 专业开发 不要被庸俗的译名迷惑， 程序员修炼之道 是一本价值极高的程序员成长手册。这本书并不局限于特定的编程语言或框架，而是提出了一套切实可行的实效（Pragmatic）开发哲学，并通过程序设计，测试，编程工具，以及项目管理等方面的实例展示了如何应用这套开发哲学，从而使得程序员更加高效专业。有人把这本书称之为迷你版 代码大全 —— 代码大全 给出了大量的优秀程序设计实践，偏向术；而 程序员修炼之道 给出了程序设计实践背后的思想，注重道。 程序员修炼之道 指出了如何成为专业程序员，这本 程序员职业素养 则指出了专业程序员应该是什么样子——承担责任；知道自己在做什么；知道何时说不/何时说是；在正确的时间编写正确的代码；懂得自我时间管理和工期预估；知道如何应对压力。如果你想成为专业程序员（Professional Developer）（而不是码农（Code Monkey）），这本书会为你指明前进的方向。延伸阅读：高效程序员的 45 个习惯 ：“敏捷”版的 程序员修炼之道 ，可以把这本书作为 程序员修炼之道 的补充；精益创业 ：尽管这是一本讲如何创业的书，但其中的精益生产，最小价值产品，以及构建-度量-学习循环都值得程序员借鉴。7. 大师之言 奇思妙想：15 位计算机天才及其重大发现 是一本极具眼光的技术访谈书籍——在这本书访谈的 15 位计算机科学家中，竟出现了 12 位 图灵奖 获得者——要知道图灵奖从 1966 年设奖到现在也只有六十几位获奖者而已。 奇思妙想 把计算机科学分为四大领域：编程语言；算法；架构；人工智能。并选取了每个领域下最具代表性的计算机科学家进行访谈。因为这些计算机科学家都是其所在领域的开拓者，因此他们能给出常人无法给出的深刻见解。通过这本书，你可以了解前三十年的计算机科学的发展历程——计算机科学家做了什么，而计算机又能做到/做不到什么。从而避免把时间浪费在前人已经解决的问题（或者根本无法解决的问题）上面。 同样是访谈录，同样访谈 15 个人， 编程人生 把重点放在程序员（Coders at work）上。它从各个领域选取了15位顶尖的程序员，这些程序员既包括 Ken Thompson 和 Jamie Zawinski 这些老牌Unix黑客，也包括 Brad Fitzpatrick 这样的80后新生代，还包括 Frances Allen 和 Donald Knuth 这样的计算机科学家。这种多样性（Diversity）使得 编程人生 兼具严谨性和趣味性，无论你是什么类型的程序员，都能从中受益良多。延伸阅读：图灵和 ACM 图灵奖（1966-2011） ：通过图灵奖介绍整个计算机科学发展史，非常难得的国产精品图书；编程大师访谈录 ：可以把这本书看作为二十年前的 编程人生 ，被访谈者都是当时叱咤风云的人物（例如微软的创造者 Bill Gates ，Macintosh 的发明者 Jeff Raskin ，以及 Adobe 的创始人 John Warnock 等等）。有趣的是这本书中大量的经验和建议到如今依然适用；编程大师智慧 ：类似于 编程人生 ，不同的是被访谈者都是编程语言的设计者——这本书覆盖了除C语言以外的几乎所有主流编程语言。通过这本书，你可以从中学到编程语言背后的设计思想——编程语言为什么要被设计成这样，是什么促使设计者要在语言中加入这个特性（或拒绝那个特性）。从而提升对编程语言的理解。8. 界面设计 书如其名， 写给大家看的设计书 是一本面向初学者的快速设计入门。它覆盖了版式，色彩，和字体这三个设计中的关键元素，并创造性的为版式设计总结出CRAP四大原则（Contrast 对比，Repetition 重复，Alignment 对齐，Proximity 亲密）。全书使用丰富生动的范例告诉读者什么是好的设计，什么是不好的设计，使得即便是对设计一无所知的人，也可以从这本书快速入门。 写给大家看的设计书 强调实践，即如何做出好的设计； 认知与设计：理解 UI 设计准则 强调理论，即为什么我们会接受这样的设计而反感那样的设计。如果你想要搞清楚设计背后的心理学知识，但又不想阅读大部头的心理学著作，那么 认知与设计 是你的首选。延伸阅读：GUI 设计禁忌 2.0 ：这本书指出了 GUI 设计的原则和常见误区，然后通过具体范例指出了如何避免这些误区。如果你的工作涉及到用户界面，那么这本书会为你减少很多麻烦；界面设计模式（第 2 版） ：这本书将用户界面中的常见元素/行为组织成彼此关联的模式，以便读者理解并举一反三，从而将其运用到自己的应用中；移动应用 UI 设计模式 ：类似于 界面设计模式 ，但面向移动平台。它给出了 iOS，Android，以及Windows Phones 上常用的 90 余种界面设计模式，从而使得你不必把这些平台的应用挨个玩一遍也可以掌握各个平台的设计精髓。如果你主攻 Android 平台，那么 Android 应用 UI 设计模式 会是更好的选择；配色设计原理 和 版式设计原理 ：如果你读过 写给大家看的设计书 之后想继续深入学习设计，这两本书是不错的起点。9. 交互设计 书如其名， 通用设计法则 给出了重要的 125 个设计原则，并用简练的语言和范例展示了这些原则的实际应用。每个原则都有对应的参考文献，以便读者进一步学习。我之所以推荐这本书，是因为：1. 程序员需要对设计有全面的认识；2. 程序员并不需要知道这些设计原则是怎么来的，知道怎么用即可。这本书很好的满足了这两个要求。 交互设计精髓 是交互设计领域的圣经级著作。交互设计专家（以及 VB 之父） Alan Cooper 在这本书中详细介绍了交互设计的原则，流程，以及方法，然后通过各种范例（主要来自桌面系统）展示了如何应用这些原则。需要注意的是这本书的 第 4 版 已经出版，它在第三版的基础上增加了移动设计以及 Web 设计等内容。延伸阅读：The Design of Everyday Things ：交互设计领域的另一本经典之作，它通过解读人类行动背后的心理活动，展示了设计问题的根源，并给出了一系列方法用以解决设计问题（需要注意，尽管这本书有中译版，但中译版对应的是 02 年的旧版，而非13年的新版）；The Inmates Are Running the Asylum ： Alan Cooper 的另一本经典，这本书非常辛辣的指出让不具备人机交互知识的程序员直接编写面向用户的软件就像让精神病人管理疯人院（The Inmates Are Running the Asylum），然后给出了一套交互设计流程以挽救这个局面；简约至上：交互式设计四策略 ：专注于把产品变的更加简单易用。作者通过删除，组织，隐藏，和转移这四个策略，展示了如何创造出简约优质的用户体验。个人成长1. 职业规划 软件开发者路线图 是一本优秀且实用的程序员职业规划手册。这本书由若干个模式组成，每个模式都对应于程序员职业生涯中的特定阶段。通过这本书，读者可以很方便的找到自己目前所处的模式（阶段），应该做什么，目标是什么，以及下一个模式（阶段）会是什么。如果你时常感到迷茫，那么请阅读这本 路线图 ，找到自己的位置，确定接下来的方向。延伸阅读：卡耐基全集 ：非常著名的为人处世书籍。很多人把这本书归类到成功学，但我并不这么认为——在我看来，这本书教的更多的是如何成为一个让大家喜欢的人。作为天天和机器打交道的程序员，这套书会帮助我们与人打交道；沃顿商学院最受欢迎的谈判课 ：这本书不是教你去谈判，而是教你通过谈判（Negotiation）去得到更多（Getting more，这也是这本书的原书书名）。小到买菜砍价，大到争取项目，这本书中的谈判原则会让你收益良多；程序员健康指南 ：作为长期与计算机打交道的职业，程序员往往会受到各式各样疾病的困扰，这本书正是为了解决这个问题而出现：它从改善工作环境，调整饮食结构，预防头痛眼痛，以及进行室内/室外锻炼等方面出发，给出了一套全面且可行的程序员健康改善计划，以帮助程序员打造健康的身体。2. 思维方式 作为程序员，我们需要不断地学习——既要学习新技术，也要学习如何解决各种领域的问题。为了提升学习效率，我们需要学习 如何学习。 程序员的思维修炼 正是这样一本讲如何学习的书，它集合了认知科学，神经学，以及行为理论的最新研究成果，并系统的介绍了大脑的工作机制。通过这本书，你将学会如何高效的使用自己的大脑，从而提高思考能力，改善学习效率。 Mastery is not about perfection. It’s about a process, a journey. The master is the one who stays on the path day after day, year after year. The master is the one who is willing to try, and fail, and try again, for as long as he or she lives.为什么同样资质的人，大多数人会碌碌无为，而只有极少数能做到登峰造极？如何在领域内做到顶尖？如何克服通往顶尖之路上的重重险阻？ 如何把事情做到最好 回答了这些问题，并极具哲理的指出登峰造极并不是结果，而是一段永不停止的旅程。阅读这本书不会让你立刻脱胎换骨，但它会指引你走向正确的道路——通往登峰造极之路。延伸阅读：怎样解题：数学思维的新方法 ：不要被标题中的“数学思维”吓到，它并不仅仅只是一本数学解题书，它所提出的四步解题法（理解题目-&gt;拟定方案-&gt;执行计划-&gt;总结反思）适用于任何领域；暗时间 ： 刘未鹏 所写的关于学习思维方法的文章集，既包含了他对学习方法的思考，也包含了大量进一步阅读的资源；批判性思维：带你走出思维的误区 ：这本书系统的分析了人类思维的常见误区，并针对各个误区给出了解决方案，从而帮助程序员养成严谨正确的思考方式；Conceptual Blockbusting: A Guide to Better Ideas ：与批判性思维相反，这本书专注于创造性思维（Creative Thinking），它分析了阻碍创造性思维的常见思维障碍（Blockbuster）以及这些思维障碍背后的成因，并给出了各种方法以破除这些障碍。3. 求职面试 知己知彼，百战不殆。 金领简历：敲开苹果微软谷歌的大门 是程序员求职的必读书籍，它覆盖了程序员求职的方方面面：从开始准备到编写简历，从技术面试到薪酬谈判。由于该书作者曾在 Google，微软，和苹果任职并进行过技术招聘，因此这本书的内容非常实用。顺便吐个槽：这本书翻译的还不错，但我实在无法理解封面上的“进入顶级科技公司的葵花宝典”这段文字——找个工作而已，用不着切JJ这么凶残吧。-_-# 同样是来自 金领简历 作者的作品， 程序员面试金典（第 5 版） 专注于技术面试题，它既包含了 IT 企业（诸如微软，Google，和苹果）的面试流程以及如何准备技术面试，也包含了大量（超过200道）常见技术面试题题目以及解题思路。无论你打算进入国内企业还是外企，你都应该把这本书的题目练一遍，以找到技术面试的感觉（我在求职时就曾经专门搞了一块白板，然后每二十分钟一道题的练习，效果很不错）。延伸阅读：编程之美：微软技术面试心得 ：恐怕是国内技术面试第一书，这本书里面的多数题目都曾经是国内IT企业面试的必问题目。这本书的缺点是它太旧而且被用滥了（以至于一些企业开始避免使用这本书上的题目）——但你可以把它当成一本算法趣题来读；剑指 Offer：名企面试官精讲典型编程题 ：相对于东拼西凑的XX面试宝典， 剑指Offer 是一本少见的国产精品技术面试书籍，尽管这本书的技术面试题目不多（60 余道），但作者为大多数题目都给出了不同方式的解法，并分析了这些解法之间的优劣，此外作者还以面试官的视角分析了技术面试的各个环节，从而帮助读者把握技术面试；人人都有好工作：IT 行业求职面试必读 ：可以把它看做 金领简历 的补充阅读——这本书的特点在于它给出了非常详细的简历/求职信/电子邮件编写技巧，而这正是不少国内程序员所缺乏的。4. 英语写作 词汇量决定阅读能力，语法决定写作能力。计算机专业词汇并不多，但精确性非常重要，因此每个程序员都应具备良好的英语语法，但程序员并不需要过于专业的英语语法——掌握常用语法并把它用对就可以。 The Only Grammar Book You’ll Ever Need 正好可以满足这个需求，尽管它篇幅不大（不足 200 页），却覆盖了英语中的关键语法以及常见错误。把这本书读两遍，它会大幅度提高你的英语写作能力。 既是最畅销的英语写作书籍，也是计算机书籍中引用最多的非计算机书籍。 风格的要素 用极其简练的语言讲述了如何进行 严肃，精确，清楚 的英语写作。从这本书中，你不仅可以学到英语写作，更可以学到一种严谨至简的处事态度，而这正是专业开发所必需的。延伸阅读：牛津英语用法指南（第 3 版） ：全面且权威的英语用法指南，它覆盖语法，词汇，发音，以及修辞等方面，并兼顾口语和书面语，以帮助读者掌握合理的英语用法（Proper English Usage）。不要被这本书的篇幅（1000 多页）吓到——原书并没有这么厚，因为这本书被翻译成中文但又得保留原有的英文内容，所以它的篇幅几乎翻了一倍。考虑到这本书使用的词汇都很基础，所以我认为具有英语基础的读者直接阅读原版（ Practical English Usage ）会更合适；写作法宝：非虚构写作指南（30周年纪念版） ：详尽的非虚构（Non-Fiction）写作指南，无论你要写地方，技术，商务，运动，艺术，还是自传，你都可以从这本书中找到珍贵的建议；中式英语之鉴 ：中国人使用英语最大的问题就是会把中式思维掺杂其中，从而形成啰里啰嗦不伦不类的中式英语（Chinglish）。 中式英语之鉴 系统的探讨了中式英语以及其成因，然后根据成因对中式英语进行归类，并对每个类别给出了大量的实际案例以及修改建议。如果你想摆脱中式英语，那么这本书是绝好的起点。如何使用这个书单学而不思则罔，思而不学则殆。不愤不启，不悱不发。举一隅不以三隅反，则不复也。不闻不若闻之，闻之不若见之，见之不若知之，知之不若行之，学至于行之而止矣。来自他人的书单它山之石，可以攻玉。我在本文最后给出其他中外优秀程序员的书单，以便参考&amp;补充。刘未鹏（暗时间作者）以下同一条目下用“/”隔开的表示任选，当然也可以都读。编码：隐匿在计算机软硬件背后的语言深入理解计算机系统 / Windows 核心编程 / 程序员的自我修养代码大全 / 程序员修炼之道编程珠玑 / 算法概论 / 算法设计 / 编程之美C 程序设计语言C++ 程序设计语言 / C++ 程序设计原理与实践 / Accelerated C++计算机程序的构造与解释代码整洁之道 / 实现模式设计模式 / 敏捷软件开发（原则模式与实践）重构云风（中国游戏编程先行者，前网易游戏部门资深程序员，简悦创始人）C++ 编程思想Effective C++深度探索 C++ 对象模型C++ 语言的设计与演化C 专家编程C 陷阱与缺陷C 语言接口与实现Lua 程序设计链接器和加载器COM 本质论Windows 核心编程深入解析 Windows 操作系统程序员修炼之道代码大全UNIX 编程艺术设计模式代码优化：有效使用内存深入理解计算机系统深入理解 LINUX 内核TCP/IP 详解洪强宁（豆瓣技术总监）代码大全人月神话编码：隐匿在计算机软硬件背后的语言计算机程序设计艺术程序员修炼之道设计模式计算机程序的构造与解释重构C 程序设计语言算法导论陈皓（CoolShell博主）点石成金：访客至上的 Web 和移动可用性设计秘笈重来：更为简单有效的商业思维黑客与画家清醒思考的艺术TCP/IP 详解UNIX 环境高级编程UNIX 网络编程张峥（微软亚洲研究院副院长）算法概论Data Structure and AlgorithmsC 程序设计语言UNIX 操作系统设计编译原理计算机体系结构：量化研究方法当下的幸福异类：不一样的成功启示录Jeff Atwood（Stackoverflow联合创始人）代码大全人月神话点石成金：访客至上的Web和移动可用性设计秘笈快速软件开发人件The Design of Everyday Things交互设计精髓The Inmates Are Running the AsylumGUI设计禁忌 2.0编程珠玑程序员修炼之道精通正则表达式Joel Spolsky（Stackoverflow联合创始人）软件项目管理人件人月神话快速软件开发编程技艺代码大全程序员修炼之道编程哲学禅与摩托车维修艺术哥德尔、艾舍尔、巴赫：集异璧之大成建筑模式语言界面设计点石成金：访客至上的 Web 和移动可用性设计秘笈交互设计精髓The Design of Everyday Things资本运作漫步华尔街图形设计写给大家看的设计书思维方式影响力Helplessness On Depression, Development and Death编程入门编码：隐匿在计算机软硬件背后的语言C 程序设计语言DHH（Ruby on Rails创始人）Smalltalk Best Practice Patterns重构企业应用架构模式领域驱动设计你的灯亮着吗？发现问题的真正所在参考怎样花两年时间去面试一个人What is the single most influential book every programmer should read?Recommended Reading for DevelopersBook Reviews – Joel SpolskyThe five programming books that meant most to me以上]]></content>
  </entry>
  <entry>
    <title><![CDATA[SEO，搜索引擎优化原理方法等整体把握]]></title>
    <url>%2F2018%2F07%2F26%2FSEO%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86%E6%96%B9%E6%B3%95%E7%AD%89%E6%95%B4%E4%BD%93%E6%8A%8A%E6%8F%A1%2Findex.html</url>
    <content type="text"><![CDATA[搜索算法：全文文字 title 标签，title里面的文字 link 链接 link 链接里的文字 站点信任度 最佳实践：一、设置title准确的描述当前网页的内容 提高站点内title的唯一性，帮助搜索引擎知道站点内每个网页的内容 简短，但能准确描述内容， 二、合理理由description当前网页展示内容的一个总结 用户需要的内容准确展示出来，吸引用户点击，增加权重 禁复制部分网页内容 禁关键字的堆叠 提高站点内description的唯一性，禁一堆网页用相同的description 即使你网页写了description，有时候还是不会展现 ，这是因为？ 描述太短或太长, 少于百度显示的字节. (推荐: 搜索引擎允许描述的字符在150个左右, 不低于135个字符, 一个汉字为2个字符)2.描述里面有乱码. (我注意到很多网页的描述是自动从文章中截取的, 如果包含乱码百度自动重新抓取. )3.设置的描述标点/空格占比太多 以上这些情况，百度会替换你自己添写的description内容。 三、优化链接URL组成简单易读，整洁，有很强的结构性 URL最好含当前页面的keyword，方便识别 禁在URL中使用不必要的参数，IDs等不能体现当前页中的内容 层级合理，禁很深层次的URL，每个层级有意义 禁一级域名和二级域名指向同一个网页 禁使用大写字母 URL地址命名要贴近目标页面的主题名称，有利于提升与目标页面的相关性，从而提升目标页面权重 URL地址的层级基于所属的类目越小越好，层级越小可以告诉搜索引擎文件存在的目录深度越小，越容易被抓取，因为只有重要的页面才会放到与根目录最近的位置，搜索引擎也会认为这些文件是网站里面相对来说比较重要的页面，优先抓取。 网页内容符合搜索引擎蜘蛛的抓取条件，被搜索引擎蜘蛛发现的URL必须可以被抓取，url中尽量减少参数，避免蜘蛛陷阱。 内链结构主要反映的是页面之间的关系，和目录结构类似，被放到首页的链接地址往往更容易被搜素引擎抓取，这里涉及到一个链接深度的概念。搜索从发现你的网站到开始抓取页面，一般都是从首页开始进行的，如果你是一个新站的话，可以从日志里面查询到。也就是说离首页越近的网址越容易被抓取到，这里同样搜索引擎会认为链接深度越小的页面，在网站里面的重要性越大，和目录结构一致，链接深度越小的页面权重也会越大，被索引的几率也会越大。 四、使你的网站易于导航在网站首页提醒出整个站点的导航 每个网页使用面包屑导航轨迹，让用户不管在哪个字页面都能很轻松的返回之前的层级 移除部分URL，依然能够达到预期的访问结果，而不是404 使用两个站点地图sitemap，一个给用户使用HTML，一个给搜索引擎XML使用 拥有一个简单的自然层级的导航 禁交叉站点内各网页链接，例如把站点内所有的网页都链接了站点内其他的网页。 禁导航断链 导航的每个节点命名都要能体现出该节点的内容 禁使用下拉导航、图片导航、动画 拥有一个有用的404页，而不是仅仅提示404；例如可导航到首页／站点内热门链接等 五、提供高质量的内容和服务容易阅读的文字，减少语法错误 禁把文字放在图片中 围绕主题keyword，不走题，合理组织段落 提供原创，唯一的高质量内容 内容以用户为主，吸引用户停留 六、优化内容中链接对链接的描述要准确，描述简明 禁使用’click here’类似的不能体现要链接网页内容的文案 禁与当前上下文无关 直接放出链接作为连接描述 统一样式 七、优化图片的使用必须使用alt属性，且描述准确，图片名有意义 使用常用图片格式jpeg,gif,png,bmp 图片链接要有规则 用图片作为链接的时候，alt要当链接描述来写 提供站点图片地图 八、合理使用HTML标签体现段落 禁滥用 九、合理使用 robots.txt十、合理使用rel=”nofollow”十一、注意事项以下几点说明过度的优化网站结构可能会出现被K的风险，总结主要由以下几点： 为了减少链接深度，首页和频道页堆砌上千条链接地址，这种情况对于前期网站权重不是很高的前提下基本上会被k的体无完肤; 索引标签的大量使用，在网站没有一定规模的文章或者其他的资源做支撑的前提下，慎重使用标签聚合站内资源，因为大量的添加索引标签可能会造成网站很多重复的页面和空页面，结果被k也是不可避免的; 详情页面勉强的增加推荐板块，造成整个页面繁杂冗余，也是不可取的，详情页本来权重在整个网站体系里面最低，再增加如此多链接，只会被降权，即使收录也不会有好的排名; 为了减少目录深度，所有的页面全部堆砌到二级目录，这种做法也是不可取的，如果整个网站除了首页全部是二级目录，也就没有主次之分，目录深度影响权重这条规则也就不可取了。 百度最新调整后的最新收录规则1.百度对新站的收录审核时长减短，从以前的半个月时间，到现在的2-3天。2.更新时间：天天更新是早上7-9点，下午调整为5-6点，晚上10-12点。周三大更新，调整为每周四大概凌晨4点更新。每月大更新的时间是11号和26号，尤其是26号，更新幅度最大，K站也是最多的。企业站内容较少的话，建议每周四前更新一下内容，内容多的话，最好是天天更新3篇。 百度对网站排名的降权规则 网站有弹窗广告这样的站点，百度给以降权。 加盟链接联盟站点的给以恰当降权。 网站页面、站点里面有大量JS代码内容的给于适当降权处置。 导出的单向链接过多，给于降权处理针对链接的站点。 友情连接过多的站点或者是不美观站点友情连接网站的，给于降权处理。 百度针对论坛和博客站点导入链接降权，论坛签名已经对百度失效。 对门户站的权重比较垂青 百度进一步提高了自身产品关键词排名的顺序， 如百度百科、百度地图、百度知道、百度贴吧、百度文库等属于百度自己的产品。还有就是百度的合作伙伴会有相应的排名优势。 公司网站排名较个人网站排名有优先权 百度认为是垃圾网站的也降权，特别是一些模板网站，持久不更新 百度算法调整后的新规定 排名点击周期 以前是关键词点击次数超于前二十名，24小时之后给予第一的排名。假如一个指数1000的关键词，排在第一位，大概每天的点击量是300，那么就需要点击超过300，24小时之后给予第一的排名。现在算法已经不是了，需要增加一个关键词点击数考核周期，每一天都有这样的流量，才会给你不错的排名。而这个周期有多长呢?不同关键词的排名周期是不一样的，不同行业的关键词周期也是不一样的。这样24小时快速提升关键词点击软件已经不好用了。 网站用户页面浏览比率 页面的浏览比率值等于独立访客(UV)比页面浏览数(PV)，一个独立客户访问一个页面跳出，属于很低的页面浏览比率，而当网站的独立访客访问越多的页面是给予的排名越好，而不单单是网站有流量就可以给予排名。 用户需求性对比 当一个用户去搜索一个关键词，点击进去的第一个结果，没有找到用户想要的内容，那么用户就会关掉页面，用户点击了几个结果后没有找到，就更换搜索词。所以搜索引擎也会把这个计算下去，会进行一个对比。当用户点击了第9个时，第9个刚好满足了他想要的内容，搜索引擎对比需求性，来进行排名微调。 百度对于不同地域，不同城市，排名展现也有所改变。 要想做出对搜索引擎友好必须做好以下四点： Baiduspider能不能找到所有网页（结构扁平化、面包屑导航。。。） Baiduspider是否知道哪个网页是重要的（离首页越近，越容易受到百度重视。。。） Baiduspider能否顺利提取网页内容（JS、Flash对百度的不友好，图片的alt和title属性。。。） Baiduspider能否在网页中提炼有用信息（代码的简化、浏览器的兼容性、可以参照百度的页面优化建议。。。） 以下四大点是百度站长学院对上面的1、2两点的全面解析：一，友好的网站结构 扁平or树型：一说到网站结构，大家都会提到扁平结构和树型结构，言必称“结构扁平化”，这些指的是物理结构，即基于内容聚合的目录及文件位置决定的结构。其实对于百度搜索引擎来说，只要结构合理、有逻辑性、内容有规律可循都可以，都是友好的。 链接结构：相对于物理结构，就要说到逻辑结构：即通过内部链接形成的链接结构，逻辑结构才是搜索引擎最关注的。对于一个网站来说，网页仅仅可以通过首页——目录1——目录2一层一层follow到是远远不够的，一个优秀的链接结构应该是网状的。 首页链接应该链向重要的频道页，频道页再链向下面的节点页或普通页面。同时，频道页、节点页和普通页面都应该可以链回到首页 无论哪些页面之间互相链接，都需要一个描述恰当的锚文本 链接不要放在JS、FLASH等搜索引擎不可见的位置，使用图片做链接入口应该完善alt标签 百度搜索引擎目前仅支持对部分JS和FLASH进行解析，绝大多数放在JS和FLASH里的链接都是获取不到的 为重要页面留更多入口。百度搜索引擎认为，获得更多内部投票的网页相对来说更加重要 “离首页越近”的网页，越容易受到百度重视。这个“近”指的是页面离首页的点击距离。即使URL所在目录层级较深，只要在首页有入口，百度也认为这是一个非常重要的页面。 不要产生可怕的孤岛页面。虽然百度在提交入口、社会化挖掘方面做了许多工作，但链接抓取依然是百度获得新页面的最重要渠道 二，通过导航让百度更好地认识站点对于用户，导航要解决的问题是：我在网站的什么位置，我想看上一级、甚至上上一级更多内容的入口在哪里；对于spider，导航要解决的问题是：这个页面属于哪个领域，要表达的主题是什么。所以说，清晰的导航系统不仅有助于提高用户体验，对SEO的意义也是重大的，所有SEO做得出色的网站基本都拥有清晰明确的导航。 导航内容搜索引擎可见：有网站的导航对用户来说美观友好，对百度来说却是不可见的。目前百度还不能搞定所有的JS和FLASH，保险起见，还是使用HTML的好。图片虽然美丽，作为导航也是对搜索引擎不友好的行为。 导航稳定：导航内容应该是相对固定的，不要让导航成为“滚动条”。 重要网页尽可能地在导航处可以follow到：百度认为主导航中出现的链接，其重要性仅次于网站首页，所以应该尽量将站内的页面在主导航中安排个位置。当然，主导航上也不可能放过多的内容，哪些链接可以上主导航还需要SEO人员进行平衡。 巧用面包屑导航：上面说到，导航对于用户来说，解决了“想看上一级、甚至上上一级更多内容”的问题，这个导航指的就是面包屑导航。面包屑导航可以使结构复杂庞大的大中型网站变得清晰轻盈，在spider进行页面解析时会着重查看面包屑导航内容，强烈建议使用。 三，合理的domain结构除了在网站建设的时候站长会思考到底使用二级域名还是子目录，在网站运营的过程中，也会考虑是否要把子目录的内容拆分成二级域名。因为很多SEO人员认为二级域名相对独立，其首页会得到百度的重视，能获得更好的排位——其实这是一个片面的错误观点，百度会通过很多指标对同domain下的二级域名和子目录进行重要程度判断，并没有武断地认为谁天生就会比谁强一些。 当SEO认为站内结构已经阻碍了网站高速发展就会考虑改版，最常见的改版便是将子目录移出主站点、单独形成二级域名。但大家都知道，改版肯定会对站点的收录排名和流量造成影响，一定要谨慎。那么在什么情况下才真的需要将子目录换成二级域名呢？其实只有一点：即子目录的内容足够丰富，且与主域的主题关联性不强！ 四，url结构很重要 url结构规律化：同一个网页有不同url，会造成多个url同时被用户推荐导致权值分散；同时百度最终选择展现的那个url不一定符合你的预期。站点应该尽量不把sessionid和统计代码等不必要的内容放在url，如果一定要这样做可以通过robots禁止百度抓取这些非规范url 最好能让用户从url即可判断出网页内容，便于蜘蛛解析的同时便于用户间传播 url尽量短 ●蜘蛛喜欢：http://tieba.baidu.com.com/f？kw=百度 ●蜘蛛不喜欢：http://tieba.baidu.com/f？ct=&amp;tn=&amp;rn=&amp;ln=&amp;cn=0&amp;kw=百度&amp;rs2=&amp;un=&amp;rs1=&amp;rs5=&amp;sn=&amp;rs6=&amp;nvselectvalue=0&amp;oword=百度&amp;tb=cn 不要添加蜘蛛难以解析的字符，如http://mp3.XXX.com/albumlist/234254;;;;;;;%B9&amp;CE%EDWF%.htmlhttp://news.xxx.com/1233，242，111，0.shtml 动态参数不要太多太复杂，目前百度对动态url已经有了很好的处理，但是参数过多过复杂的url有可能被蜘蛛认为不重要而抛弃]]></content>
      <tags>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地配置DNS服务器（MAC版）]]></title>
    <url>%2F2018%2F07%2F26%2F%E6%9C%AC%E5%9C%B0%E9%85%8D%E7%BD%AEDNS%E6%9C%8D%E5%8A%A1%E5%99%A8MAC%E7%89%88%2Findex.html</url>
    <content type="text"><![CDATA[作为一个前端开发者，会遇到使用cookie的情况，常见的如：登录，权限控制，视频播放，图形验证码等，这时候本地开发者在PC上会使用修改hosts的方式添加指向本地的域名，来获取cookie的同域名。如：1127.0.0.1 local.skylor.com 但是在移动端的时候，这一招就不好使了，苹果手机在没越狱的情况下是没法修改hosts的，难道为了这个让自己的爱机越个狱？答案应该是否定的。那么怎么处理这个问题呢？完美解决方案就是配置本地局域网的DNS服务。于是我就查询了一系列的文档文章，总结出这篇文章，踩过些许坑，希望后来人别在重复踩了，由于本人使用的是Mac，所以下面的一些命令亲和Mac党，其他系统也类似，只有写系统命令可能不同，废话不多说，君且详看： 安装1brew update; brew install dnsmasq; 启动1sudo brew services start dnsmasq 重启1sudo brew services restart dnsmasq 停止1sudo brew services stop dnsmasq 查看dnsmasq的运行1ps aux | grep dnsmasq 找到运行参数1/usr/local/opt/dnsmasq/sbin/dnsmasq --keep-in-foreground -C /usr/local/etc/dnsmasq.conf 找到运行配置文件：1/usr/local/etc/dnsmasq.conf 编辑他，这里用vim：1sudo vim /usr/local/etc/dnsmasq.conf 干下面这些事情，去掉以下注释，并修改，具体配置是干啥的，后面会有讲到：1234no-resolvno-polllisten-address=127.0.0.1,172.17.7.115addn-hosts=/etc/dnsmasq.hosts 添加自定义hosts文件dnsmasq.hosts1sudo vim /etc/dnsmasq.hosts 里面添加你需要填写的域名对应关系，如：1172.17.7.115 yongle.skylor.com 重启下你的DNS服务器，启动代码在文章上面有说到，截至目前，你的Mac本地的DNS配置就OK了，但是让同局域网的其他设备使用的话，还需要一些操作。 修改路由器的DHCP配置DNS1172.17.7.115 备用DNS配置为一般常用DNS服务器就好了。 局域网内设备需重连WIFI，而后就可以使用你本地的DNS服务了，检测是否成功，可以使用dig命令，如你本机上可这么来：1dig yongle.skylor.com @127.0.0.1 当你看到1yongle.skylor.com. 0 IN A 172.17.7.115 说明成功了，这时候应该就结束了，但若还有局域网内的设备连不上的话，可以查看下该设备的DNS是否含有172.17.7.115，若没有，重启wifi连接，就OK了。]]></content>
      <tags>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用SQL语句（postgresql）获取所有表名、字段名、字段类型、注释]]></title>
    <url>%2F2018%2F07%2F26%2F%E4%BD%BF%E7%94%A8SQL%E8%AF%AD%E5%8F%A5postgresql%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E8%A1%A8%E5%90%8D%E5%AD%97%E6%AE%B5%E5%90%8D%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B%E6%B3%A8%E9%87%8A%2Findex.html</url>
    <content type="text"><![CDATA[获取表名及注释：1234567891011SELECT relname AS tabname, CAST ( obj_description ( relfilenode, 'pg_class' ) AS VARCHAR ) AS COMMENTFROM pg_class CWHERE relkind = 'r' AND relname NOT LIKE'pg_%' AND relname NOT LIKE'sql_%'ORDER BY relname; 过滤掉分表： 加条件 and relchecks=0 即可 获取字段名、类型、注释、是否为空:123456789101112131415SELECT a.attnum ,a.attname AS name ,format_type(a.atttypid, a.atttypmod) AS typ ,a.attnotnull AS notnull ,coalesce(p.indisprimary, FALSE) AS primary_key ,f.adsrc AS default_val ,d.description AS col_commentFROM pg_attribute aLEFT JOIN pg_index p ON p.indrelid = a.attrelid AND a.attnum = ANY(p.indkey)LEFT JOIN pg_description d ON d.objoid = a.attrelid AND d.objsubid = a.attnumLEFT JOIN pg_attrdef f ON f.adrelid = a.attrelid AND f.adnum = a.attnumWHERE a.attnum &gt; 0AND NOT a.attisdroppedAND a.attrelid = 'public.smartsa_training'::regclass -- table may be schema-qualifiedORDER BY a.attnum;]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客说明]]></title>
    <url>%2F2018%2F07%2F26%2F%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E%2Findex.html</url>
    <content type="text"><![CDATA[这一天，又有人加到我的QQ了，说是通过我的博客来的，正在看我的 Github。鬼使神差的我，通过 github 报告查看了下自己的情况，猛然间发现输出最多的时候却还一直是 2015 年，也就是说那以后的几年来我都处于零输出，或者是低输出的状态，于是便重视了起来。 翻看完自己的所有博客账号，发现确实好久没更新了，且还有很多的债务没有偿还！！仰天长舒了一口气，回想这一路，不停的学习，不停的折腾，却越来越少的去分享，去整理，去总结。或许我正在一条错误的道路上渐行渐远……惊恐万分！ 一直以来（高中时发现并延续下来的吧），我都认为单单的闷头学习达不到很好的学习效果，只有在实践中。。。咳咳。。。只有在教人，传授的时候，并且能够让你教的人能够明白你所学的你所想教的，因为看上去是你在传授知识，实际上你也在整理总结知识，在这个过程中，一定会发现之前没有理解透彻的地方现在明白了。于是我想了下自己：有个三方博客 cnblog，有个自建博客 fangyongle.com。那么为啥又出来这次的 github 静态博客呢？ 自建博客秉承着不倒腾就会 die 的原则，作为一个技术出生的我怎能不搭建自己的博客呢，于是倒腾了起来。。。。。。 可当博客上线后，不倒腾就会 die 的我又在博客所在的服务器上继续倒腾起其他东西来，穷苦的我租用的是最低配置服务器，用过的都知道，那是小姑娘经不起折腾的，于是有个担忧涌上心头，博客的数据库我是建在服务器上的，如果服务器没了，文章也就没了呀。自建博客，不可取不可取，因为我是屌丝程序员。 三方博客程序员浏览大家之长，成自家后花园。各大博客都去过，有些留下了点什么，有些不带走一片砖瓦。最开始的是博客园，最多的也是博客园，现在看了下，总浏览量有 50k+ 了。流量不错，猜测是SEO的功劳，和一些扒手网站带来的流量。可持续下来，但不符合”倒腾”呀，不可取，不可取。 Github博客这个倒是符合哈，每天浏览次数最多的网站，倒腾的代码存放的地方，免费空间，大厂，保存较为久远，且为静态文件，易迁移，八错八错，于是就倒腾起来了…… 总结想了下：三方博客和Github博客可以同时进行。（毕竟在博客园的博客上欠了很多债）。就酱。]]></content>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo搭建博客]]></title>
    <url>%2F2018%2F07%2F26%2F%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2Findex.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
</search>
